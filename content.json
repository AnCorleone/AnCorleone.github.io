[{"title":"Java设计模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/Java设计模式/","text":"设计原则1.单一职责原则 : 一个类只负责一个功能领域中的相应职责 2. 开闭原则 : 一个软件实体应当对扩展开放，对修改关闭 3. 里氏代换原则 : 所有应用基类（父类）的地方，必须能透明的使用其子类对象 使用原则 : 在程序设计时,尽量使用基类类型对对象进行定义,而在运行时再确定子类类型,用子类对象替换父类对象 4. 依赖倒转原则 抽象不应该依赖于细节,细节应当依赖于抽象.换言之就是,要面向接口编程,而不是针对实现编程. 程序代码中传递参数或关联关系时,尽量应用层次高的抽象层类,既使用抽象类,接口进行变量类型声明,参数声明,返回值类型声明,以及数据类型的转换等,而不要用具体的类来做这些事.","tags":[]},{"title":"MySql的修改和删除.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/MYSQL的修改和删除/","text":"数据库的修改和删除 打开数据库 ‘sudo service mysql start’ 登录数据库 ‘mysql -u root -p’ 查看数据卡 show databsaes 删除数据库 drop databsaes 数据库名 连接数据库 use 数据库名 显示数据库中的表 show tables 查看表中的类容 select * from 表名 修改表的名字 rename table 旧表名 to 新表名 删除一张表 drop table 表名 增加列 alter table 表名 add column 列名字 数据类型 约束 eg: alter table employee add height int(4) default 170 (给employee 表增加height列 ) 增加列并指定新增列的位置 使用after eg: alter table employee add height int(4) dafault 170 after age ; 新增加列放在第一个使用 first 删除一列 alter table 表名 drop column 列名字 修改表中的某个值 update 表名 set 列1=值1，列2=值2 where 条件 eg: update employee set age=24,salary=300 where name = ‘Tom’ 根据条件删除一列 delete table from employee where name=’Tom’; 索引 增加索引 create index 索引名字 on 表名（列名）eg : create index idx_id on employee(id) 视图视图是从一个或多个表中取出数据在窗口中展示，可以看作一张表，但数据依赖原表 创建视图的语句: create view 视图名字（列a,列b，列c) as select 列1,列2,列3 from 表名eg : create view v_emp(v_name,v_age,v_salary) as select name,age,salary from employee; 导入 把文件中的数据导入表中 导入语句格式 load data infile ‘文件路径’ to 表名eg: load data infile ‘/home/anakin/MySql/SQL6/in.txt’ to employee 导出 将表中的数据导出到文本中 导出的语句格式：select name,age into outfile ‘文件路径和文件名’ from 表名eg : select * into outfile ‘/tmp/out.txt’ from employee 数据库备份 使用mysqldump备份数据库，生成sql脚本文件 备份整个数据库 mysqldump -u root 数据库名&gt;备份文件名 备份数据表 mysqldump -u root 数据库名 表名&gt;备份文件名 eg : mysqldump -u root -p mysql_shiyanlou&gt;bak.sql; 数据库恢复 恢复数据的语句： 使用source sql 脚本 新建一个数据库 create database test; 恢复数据 mysqldump -u root -p test&lt;bak.sqp","tags":[]},{"title":"MySQL基本操作.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/MySQL进阶-操作详解/","text":"MySQL基本操作 打开数据库 sudo service mysql start; 连接数据库 mysql -u root -p 查看数据库 show dabases 使用数据库 use 数据库名字 创建数据库 create database 数据库名 eg : create database test 创建表 create table 表名（列名 数据类型 约束）eg : create table pet(name VARCHAR(20),owner VARCHAR(20),species VARCHAR(20),sex CHAR(1),birth DATE , death DATE); 查看创建的表 DESCRIBE pet; 插入数据 insert into test VALUES(‘tom’,’panda’,’hamster’,’f’,’2017-02-06’，NULL); 从表中检索数据 select * from pet;","tags":[]},{"title":"观察者模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-观察者模式/","text":"观察者模式实现过程 观察者模式基本组成是，观察者Observer和被观察者（观察目标）Subject,当目标发生改变的时候，观察者会随之改变 一个被观察者可以被多个观察者观察 被观察者一般提供一个集合保存观察者，提供对观察者的管理，删除和增加观察者，提供一个抽象的notify方法，由具体的被观察者实现，实现方式为，遍历观察者的集合，调用观察者的update()方法，通知每一个观察者 观察者申明为一个接口，一般提供update()方法，由不同的观察者去实现，具体的观察者在接收到观察者的notify()后做出相应的更新 要点 观察者提供update()方法，在update()方法中变量观察者的集合，调用观察者的update()方法 一般定义被观察者为抽象类提供管理观察者的方法，和抽象的notify()方法 一般将观察者声明为接口，提供update()方法，由具体的观察者去实现，根据需要对被观察者的改变做出不同的实现 实例 背景： 以游戏为例，多人组队玩一个游戏，当有一个人遭受攻击时向控制中心发消息，控制中心收到消息通知每个队友，队友收到消息过来支援 每个队员都作为观察者，被观察者为控制中心 当有队员Player受到攻击时，调用控制中心的notifyObsever() 方法，在notifyObsever()方法中遍历观察者也就是所有队员，会调用所有队友的help() 方法 代码过程 观察者的接口 ：观察者的接口Observer 申明了help（），beAttached()方法 具体的观察者 ：具体的观察者Player类，实现接口中的方法 被观察者抽象类 ：被观察者抽象类AllyControlCenter,包括对观察的管理的集合和join()和quit()方法，和通知每个观察者的抽象方法notifyObsever()方法， 被观察者 ：被观察者的实现类ConcreteAllyControlCenter ，是先notifyObsever()方法，遍历观察者集合，调用每个人观察者对象的help()方法 客户端 ：创建观察者对象Observer player = new Player()，创建被观察者实例AllyControlCenter ally = new ConcreteAllyControlCenter();，将观察者加入到集合中， all.join(Player),player调用beAttached(),所有观察者收到消息调用help()方法，（当被观察者触发beAttached() 方法时候，在beAttached()中调用notifyObsever() 方法通知每个观察者调用help()方法） 代码调用流程 player.beAttached()—–&gt; AllyControlCenter.notifyObsever()—-&gt; player.help()","tags":[]},{"title":"简单工厂模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-简单工厂模式/","text":"## 简单工厂模式 定义抽象的工厂类 工厂类包定义公共的方法实现，和不同实现的抽象方法 定义根据参数创建实例对象，返回抽象类的静态方法 使用静态方法传入要获取对象的tag,获取对象的实例，调用实例的方法","tags":[]},{"title":"模版模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-模版模式/","text":"##模版模式 定义 :定一个操作中的算法框架,而将一些步骤延迟到子类中,使子类不用改变算法的结构重新定义算法中的步骤. 使用场景 多个子类共有方法并且逻辑基本相同 重要,复杂的核心算法,可以把核心算法设计成模版方法,周边的具体细节由子类去实现 重构时,将相同的代码抽取到父类中,然后通过子函数约束其行为 使用示例 以电脑开机为例,基本过程相同,不同的电脑具体细节不同 开机的父类定义模版方法,调用开机的过程 package com.anakin.design_pattern_test.demo.singel_instance.templatemethod; /** * Created by demo on 2017/2/8 0008 */ public abstract class OpenComputer { public void loadOs() { System.out.println(&quot;加载系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } public void checkHardware() { System.out.println(&quot;检查防火墙&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } public void powerOn() { System.out.println(&quot;连接电源&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } public void login() { System.out.println(&quot;验证登录系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } public final void startUp(){ System.out.println(&quot;=========== open start ============&quot;); powerOn(); checkHardware(); loadOs(); login(); System.out.println(&quot;=========== open end ============&quot;); } } 以程序员的电脑和军人的电脑开机为例,程序在登录的时候需要输出密码,而军人的电脑在开机的过程中需要检查防火墙 程序员的电脑 package com.anakin.design_pattern_test.demo.singel_instance.templatemethod; /** * Created by demo on 2017/2/8 0008 */ public class CoderComputer extends OpenComputer { @Override public void login() { // super.login(); System.out.println(&quot; ......... coder&apos;s computer open login &quot;); } } 军人的电脑 package com.anakin.design_pattern_test.demo.singel_instance.templatemethod; /** * Created by demo on 2017/2/8 0008 */ public class MilitaryComputer extends OpenComputer { @Override public void checkHardware() { System.out.println(&quot; military&apos;s is check haedware !!!!!!!!!!!&quot;); } } 测试 // 模版模式测试 OpenComputer coderPc = new CoderComputer(); coderPc.startUp(); OpenComputer militaryPc = new MilitaryComputer(); militaryPc.startUp(); 测试结果 02-08 08:53:19.246 3221-3221/com.anakin.design_pattern_test I/System.out: =========== open start ============ 02-08 08:53:19.246 3221-3221/com.anakin.design_pattern_test I/System.out: 连接电源&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.246 3221-3221/com.anakin.design_pattern_test I/System.out: 检查防火墙&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.246 3221-3221/com.anakin.design_pattern_test I/System.out: 加载系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.247 3221-3221/com.anakin.design_pattern_test I/System.out: ......... coder&apos;s computer open login 02-08 08:53:19.247 3221-3221/com.anakin.design_pattern_test I/System.out: =========== open end ============ 02-08 08:53:19.247 3221-3221/com.anakin.design_pattern_test I/System.out: =========== open start ============ 02-08 08:53:19.247 3221-3221/com.anakin.design_pattern_test I/System.out: 连接电源&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.248 3221-3221/com.anakin.design_pattern_test I/System.out: military&apos;s is check haedware !!!!!!!!!!! 02-08 08:53:19.248 3221-3221/com.anakin.design_pattern_test I/System.out: 加载系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.248 3221-3221/com.anakin.design_pattern_test I/System.out: 验证登录系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.253 3221-3221/com.anakin.design_pattern_test I/System.out: =========== open end ============","tags":[]},{"title":"桥接模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-桥接模式/","text":"桥接模式使用实例以两个程序绘制圆形和方形为例 定义两个绘图程序类 DP1,DP2,定义绘制方法 抽象两个形状的派生类 shape","tags":[]},{"title":"工厂方法模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-工厂方法模式/","text":"工厂方法模式 和简单工厂模式不同是,简单工厂模式,实例都由一个工厂类创建,工厂类的代码量会比较多,而且增加新的对象需要修改工厂类的代码,增加if else 的判断. 工厂模式,创建产品的抽象类和实现类,以及工厂的抽象类和实现类. 以打印log为例,log的存储方式可以是db也可以是file中,需要创建Logger的抽象类,具体是FileLogger实现类和DbLogger的实现类,工厂的抽象类LoggerFactory,和具体的实现类DbLoggerFactory,FileLoggerFactory 在抽象Logger类中定义公共的抽象方法writeLog() 在具体实现类DbLogger和FileLogger中实现各自的具体的writeLog方法 在抽象的工厂类中定义抽象的创建对象的方法creatLogger() 在具体的实类DbLoggerFactory,FileLoggerFactory中实现方法,创建DbLogger和FileLogger的实例,并返回其父类Logger 客户端的使用 : 根据需要创建工厂的实例,调用实例中创建对象的方法creatLogger返回具体log存放的实例对象,在调用具体打印log的方法writeLog()","tags":[]},{"title":"Builder模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-Builder模式/","text":"Builder模式定义:将复杂的创建与他的表示分离,使同样的创建过程可以创建不同的表示 设计的步骤:Builder builder = new AppleBuilder(); Director director = new Director(builder); director.construct(4,2,&quot;linux&quot;); Log.d(TAG,&quot;test result &gt;&gt;&gt;&gt;&gt; :: &quot; +builder.create().toString()); 以组装电脑为例,创建电脑的抽象类,包含os ram,core定义,提供设置的抽象方法 创建要组装的具体电脑类AppleComputer,继承Computer类,实现所用方法 创建抽象的Builder类,提供builder的设置方法,另外提供返回Computer的create的抽象方法 创建具体的AppleBuilder类实现抽象方法,创建AppleComputer 实例对象,并设置数据,返回AppleComputer的实例 创建具体的Director类,构造方法中接受builder对象,提供接受数据的construct 方法,将参数传递给builder对象 传递的参数最终被AppleBuilder接收,并返回一个具体的AppleComputer对象 具体代码package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public abstract class Computer { protected int mCore = 1; protected int mRam = 10; protected String mOs = &quot;dos&quot;; protected Computer() { } public abstract void setCore(int core); public abstract void setRem(int rem); public abstract void setOs(String os); @Override public String toString() { return &quot;Computer{&quot; + &quot;mCore=&quot; + mCore + &quot;, mRam=&quot; + mRam + &quot;, mOs=&apos;&quot; + mOs + &apos;\\&apos;&apos; + &apos;}&apos;; } } package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public class AppleComputer extends Computer { protected AppleComputer() { } @Override public void setCore(int core) { this.mCore = core; } @Override public void setRem(int ram) { this.mRam = ram; } @Override public void setOs(String os) { this.mOs = os; } } package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public class AppleBuilder extends Builder { private Computer mApplePc =new AppleComputer(); @Override public void buildCore(int core) { mApplePc.setCore(core); } @Override public void buildRam(int ram) { mApplePc.setRem(ram); } @Override public void buildOs(String os) { mApplePc.setOs(os); } @Override public Computer create() { return mApplePc; } } package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public abstract class Builder { public abstract void buildCore(int core); public abstract void buildRam(int ram); public abstract void buildOs(String os); public abstract Computer create(); } package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public class Director { Builder mBuilder=null; public Director(Builder builder) { mBuilder = builder; } public void construct(int core,int ram, String os){ mBuilder.buildCore(core); mBuilder.buildRam(ram); mBuilder.buildOs(os); } } 测试代码 // 测试运行效果 Builder builder = new AppleBuilder(); Director director = new Director(builder); director.construct(4,2,&quot;linux&quot;); Log.d(TAG,&quot;test result &gt;&gt;&gt;&gt;&gt; :: &quot; +builder.create().toString());","tags":[]},{"title":"Android基础知识.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/Android基础知识-md/","text":"Android学习笔记 五种布局LinearLayout(线性布局) 一行或者一列值放置一个控件的布局,可以设置方向,垂直排列或者水平排列,适用于简单的布局 适用场景:水平或者垂直的简单排列,如登录界面 RelativeLayout(相对布局) 是一个相对自由的布局, 由一个view作为参照,来定位下一个view的摆放位置,可以实现比较复杂的布局 应用场景:适合比较复杂的布局,LinearLayouy能实现的它也能实现 FrameLayout(框架布局) 所有的子view都会放在左上角,无法指定位置,后面的子view会放在前一个view上. 使用场景: 放置单一的view,如放置Fragment,显示一张图片 TableLayout(表格布局) 类似HTML中的table,使用tableRow来布局,tableRow代表一行,其中的每个视图组件代表一个单元格 使用场景:空间之间存在相应关系 AbsoluteLayout (绝对布局) 采用坐标轴的方式来定位view,左上角坐标为(0,0),x轴向右递增,y轴向下递增 使用场景:准确定位控件位置,但是Android设备的屏幕尺寸,分辨率差别很大,无法解决适配问题,该布局已经过时 Activity- Activity的生命周期 正常的生命周期:onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory 转到其他Activity或者按下home键 执行onPause() -&gt; onStop 进入停滞状态 Activity返回前台:onRestart() -&gt; onStart() -&gt; onResume() 当系统内存不足会将后台的Activity杀死,此时这个Activity任然在任务栈中只是引用指向的对象已经为空,若再次回到这个Activity会重新走一遍生命周期 锁屏: onPause -&gt; onStop 解锁: onStart -&gt; onResume Activty任务栈 任务栈是一种先进后出的结构,每个app默认只有一个任务栈以包名命名,位于栈顶的Activity处于焦点状态,当按下back键时,栈内的Activity会一个一个出栈,调用onDestory()方法,如果栈内没有Activity,系统就会回收这个栈. 启动模式: standard :默认的启动模式,每次创建一个新的Activity实例,将其压入任务栈栈顶,不管栈内是否存在这个Activity.Activity启动三次就会调用三次Activity的生命周期. singleTop:栈顶复用模式,启动一个Activity,如果栈顶存在这个Activity的实例,就不在创建新的Activity实例,启动多次也不会创建新的实例,会调用Activity的newIntance()方法,如果栈内存在这个Activity的实例,但不是在栈顶,作用与standard模式一样 singleTask:栈内复用模式,创建Activity的时候,系统会确认它需要的任务栈是否已经创建,否则再创建任务栈,然后放入Activity,如果栈内有一个Activity实例,那么这个Activity会被调到栈顶,调用newInstance()方法,并且会清理这个实例上面的所有Activity singleInstance:加强版的singleTask模式,这种模式Activity实例会单独存在一个任务栈中,由于栈内复用的特性,以后不会再创建新的实例,除非任务栈被销毁 Activity的堆栈管理是以ActivityRecord为单位的,所有的ActivityRecord都放在一个list中,可以认为一个ActivityRecord就是一个Activity栈 Activity的缓存 有两个Activity A,B ,从A进入B,一段时间后,系统可能叫A回收,这时在按back键回到A,会重新走A的生命周期方法onCreate -&gt; onStart -&gt; onResume ,A被重新创建了一次,这时A中保存的数据和状态就会丢失 为了恢复状态,使用onSaveInstanceState()方法保存临时数据和状态,此方法会在Activity销毁前调用,方法中有Bundle参数保存,putString(),putInt()等方法,方法中传入一个参数好一个值,数据保存后会在onCreate()中恢复 onSaveInstanceState调用时机:即系统未经你允许销毁了你的Activity,这是系统的责任，因为它必须要提供一个机会让你保存你的数据 onSaveInstanceState() 会在onStop()前执行,但不保证是在onPause之前还是之后触发 代码 private static final String TAG = &quot;MainActivity&quot;; private static final String SAVE_KEY =&quot;save_key&quot; ; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(savedInstanceState!=null){ // 恢复保存的内容 String save = savedInstanceState.getString(SAVE_KEY); Log.d(TAG,&quot;=== 恢复保存的内容 ==&quot;+save); } initEvent(); } /** * 保存Activity的状态 * @param outState * @param outPersistentState */ @Override public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) { super.onSaveInstanceState(outState, outPersistentState); outState.putString(SAVE_KEY,&quot;保存字符串&quot;); } Intent Intent可以传递的数据类型:可以传递基本数据类型好基本数据类型的数组,以及实现需序列化接口的飞基本数据类型 FragmentFragment的生命周期和Activity的关系onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onViewCreatd() -&gt; Activity onCreated() ….. Fragment的生命周期 Broadcast Receiver的两种动态注册和静态注册有什么区别 动态注册: 在代码中注册,app退出就不能接收到广播 静态注册: 在清单文件中注册,app退出依旧可以接受到广播 ContentProvider使用方法Service为什么在Service中创建子线程 在Activity中创建一个子线程,但Activity被销毁后,就不能获取子线程的实例,而且在在其他Activity中无法对其操作 在Service创建中就不同,所有的Activity都可以对其进行操作,即使Activity 被销毁后,重新与Service进行关联,就可以获取Binder的实例.因此使用Service做后台处理,Activity可以放心的finish ,不用担心对后台任务无法控制的情况 Service的两种启动方法,有什么区别 Context bindService 启动Service 生命周期好Context 绑定在一起 Context startService 启动Service 生命周期和context 无关 如何保证Service不被杀死动画有哪几类,各有什么特点,有什么区别Android的数据存储形式Sqlite的基本操作如何判断应用被强杀Json有什么优劣势Asset目录与res目录的区别优化Android怎么加速启动ActivityAndroid内存优化方法自定义View的流程Android长连接,怎样处理心跳机制View的绘制流程下拉刷新的实现原理常用框架和源码分析，底层原理Android新特性5.06.07.0ContextIntenService使用场景图片缓存查看程序可用最高内存Gradle构建工具","tags":[{"name":"Android","slug":"Android","permalink":"http://yoururl.com/tags/Android/"}]},{"title":"Android-读取XML中的配置参数工具类XMLUtil.md","date":"2017-01-20T02:22:04.000Z","path":"2017/01/20/读取XML中的配置参数/","text":"一个读取xml文件中配置文件的工具类XMLUtil代码如下：import javax.xml.parsers.*; import org.w3c.dom.*; import org.xml.sax.SAXException; import java.io.*; public class XMLUtil { //该方法用于从XML配置文件中提取配置文件 public static String getChartType() { try { //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;config.xml&quot;)); //获取包含配置文件的文本节点 NodeList nl = doc.getElementsByTagName(&quot;chartType&quot;); Node classNode = nl.item(0).getFirstChild(); String chartType = classNode.getNodeValue().trim(); return chartType; } catch(Exception e) { e.printStackTrace(); return null; } } } XML 文件代码&lt;?xml version=&quot;1.0&quot;?&gt; &lt;config&gt; &lt;chartType&gt;histogram&lt;/chartType&gt; &lt;/config&gt;","tags":[]},{"title":"MySQL使用.md","date":"2017-01-20T02:22:04.000Z","path":"2017/01/20/MySQL使用/","text":"##ubuntu下使用MySQL## ###安装MySQL### 安装核心服务 sudo apt-get install mysql-server 安装客户端 sudo apt-get install mysql-client ###创蚩菘獾幕静僮?## 打开MySQL :sudo service mysql start 使用root:mysql -u root -p 查看数据库 :show databases; 连接数据库:use&lt;数据库名&gt; 查看表:show tables; 退出:quit 或者exit ###创建数据库和表### 创建数据库: CREATE DATABASES &lt;数据库名? 创建表 : CAEATE TABLE &lt;表名&gt;(?…); ###查询表### 查询全部select * from 表名 条件查询: select 要查询的列名 from where 限制条件 ###条件查询### where后面限制条件可以有数学符号= ,&lt;,&gt;,&gt;=,&lt;= and or : select * from employee where age30; in 和not in:表示在或者不在某个范围内的结果,select name,age,in_dpt FROM employee WHERE in_dpt IN(‘dpt3,dpt4’); LIKE 通配符 ‘‘ 匹配任意字符一个’‘匹配一个字符,’%’匹配不定个字符eg: select name,age FROM employee WHERE phone LIKE ‘11%’###对结果排序### 为了对结果排序,使用ORDER BY排序关键词,默认是升序,使用ASC的DESC可以指定升序或者降序,比如按salary降序排列 降序排列:SELECT name,age,salary,phone FROM employee ORDER BY salary DESC; ###SQL内置函数和计算### COUNT SUM AVG MAX MIN 分别为计数 求和 求平均 最大值 最小值 使用AS关键字给值重命名eg : select max(salary),min(salary) from employee; select count(sum) as salary_count from emplary; ###子查询### 处理多个表才能获取信息,如获取name =’Tom’所在的in_dpt,做了几个projecteg: select count(proj_name) from project where of_dpt in(select in_dpt from employee where name =’Tom’) ###插入语句### insert into 表名(键名) values(值) insert into 表名 values(值) ##约束##常见的约束 主键 PRIMARY KEY 默认值 DEFAULT 唯一UNIQUE 外键FOREIGN KEY 非空 NOT NULL###建立含约束的表###","tags":[]},{"title":"自学Python-常用内建模块","date":"2017-01-14T04:03:14.000Z","path":"2017/01/14/自学Python-常用内建模块/","text":"Python内建模块关于时间# 1. 获取当前时间 from datetime import datetime,timedelta r =datetime.now() print (r) # 2. 获取指定的时间和日期 r1 = datetime(2017,1,14,12,53) print (r1) # 3. 将datetime转换为datestamp t= 12345645.12 r2 = datetime.fromtimestamp(t) print(r2) # 4. str转换为datetime r3 = datetime.strptime(&apos;2017-01-14 15:58:29&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;) print(r3) # 5. datetime转换为str s1 = datetime.now() r4 = s1.strftime(&apos;%a, %b %d %H:%M&apos;) print(r4) # 6. 时间的加减 n1 = datetime.now() print(n1) n2 =n1+timedelta(hours=10) # 增加10小时 print (n2) collections collections是Python的内建模块提供集合操作的类 # Python的内建模块 - collections # 1. 使用namedtuple表示一个点的坐标 from collections import namedtuple,deque,defaultdict,OrderedDict Point = namedtuple(&apos;point&apos;,[&apos;x&apos;,&apos;y&apos;]) p =Point(1,2) print(p.x) print(p.y) # 2. deque 高效的对list进行删除和插入 d = deque([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) s = d.appendleft(&apos;x&apos;) d.append(&apos;z&apos;) d.pop() print(s) print(d) # 3 .defaultdict ,使用dict的时候如果应用的key不存在会抛出keyError ,使用defaultdict 返回一个默认值 dd = defaultdict(lambda :&apos;N/A&apos;) dd[&apos;key1&apos;] =&apos;anakin&apos; s1 = dd[&apos;key1&apos;] s2 = dd[&apos;key2&apos;] print(s1) print(s2) # 4. 使用OrderedDict ,dict 是无序的,迭代的时候不能按照顺序取出数据,使用OrderedDict d1 = dict([(&apos;a&apos;,&apos;1&apos;),(&apos;b&apos;,&apos;2&apos;),(&apos;c&apos;,&apos;3&apos;)]) print(d1) d2= OrderedDict([(&apos;a&apos;,&apos;1&apos;),(&apos;b&apos;,&apos;2&apos;),(&apos;c&apos;,&apos;3&apos;)]) print (d2) # 注意 OrderedDict会按照插入的顺序排序,而不是按照key 的顺序 d3 = OrderedDict() d3[&apos;x&apos;]=3 d3[&apos;z&apos;]=6 d3[&apos;d&apos;]=4 print d3 计数函数Counter 统计字符出现的次数 # Counter 计数的方法,可以统计字符出现的次数 c = Counter() for ch in &apos;luoyang&apos;: c[ch]= c[ch]+1 print (c)","tags":[]},{"title":"自学Python-正则表达式","date":"2017-01-14T02:46:38.000Z","path":"2017/01/14/自学Python-正则表达式/","text":"正则表达式 [0-9a-zA-Z_]匹配任意数字字母和下划线 [0-9a-zA-Z_]+ 匹配至少一个字母数字下划线组成的字符串 [a-zA-Z_][0-9a-zA-Z_]* 匹配以字母或者下划线开头，后面跟任意个字母或数字 [a-zA-Z_][0-9a-zA-Z_]{0，19} 匹配一字母或者下划线开头，后面0到19个数字或者字母下划线 A|B 可以匹配 A或者B ，（P\\p)ython可以匹配python,或者Python ^ 表示行的开头 ^\\d表示以数字开头 $ 表示行的末尾 re模块 判断表达式是否匹配成功,如果成功,返回一个Match对象,失败返回None # 判断一个电话号码 s= re.match(r&apos;^\\d{3}-\\d{3,8}$&apos;,&apos;012-1234&apos;) print (s) 切割字符串 # 通过空格切割字符串 str = &apos;q we r t&apos; r =re.split(r&apos;[\\s]+&apos;,str); print (r) 分组 除了简单的匹配,正则表达式还可以提取子串,用()表示要提取的分组(Group) # 提取分组 # 提取区号和电话号码 s = re.match(r&apos;^(\\d{3})-(\\d{3,8})$&apos;,&apos;021-5386112&apos;) print (s) g1 =s.group(1) g2 =s.group(2) print (g1) print (g2) 预编译 如果执行横多次的正则匹配,每次执行都要对正则表达式进行编译,出于效率我们可以预编译正则表达式 # 编译 re_tel = re.compile(r&apos;^(\\d{3})-(\\d{3,8})$&apos;) # 使用 s = re_tel.match(&apos;021-5386112&apos;).group() print (s)","tags":[]},{"title":"自学Python-线程和进程","date":"2017-01-13T07:05:52.000Z","path":"2017/01/13/自学Python-线程和进程/","text":"multiprocessingwindows 创建多线程使用 multiprocessinglinux unix 使用fork() 创建子线程的时候,只需要传入一个函数,和一个参数,创建一个Process实例,用start()方法启动,这样创建进程比fork()简单 from multiprocessing import Process import os # 子进程要执行的代码 def run_proc(name): print(os.getpid()) print(name) print(__name__) if __name__ == &apos;__main__&apos;: print(&apos;prent process %s&apos;%os.getpid() ) # 创建一个子线程 p = Process(target = run_proc,args = (&apos;test&apos;,)) print(&apos; child process will start &apos;) # 开始子线程 p.start() # 放如线程队列 p.join() print(&apos; child process end &apos;) Pool如果要开启大量子线程,可以用线程池批量化创建子线程 from multiprocessing import Pool import os,time,random def long_time_task(name): print(&apos; 开启新的任务...&apos;+name) start = time.time() time.sleep(random.random() * 3) end = time.time() s = end - start print(s) print(name) if __name__==&apos;__main__&apos;: p = Pool(4) for i in range(5): print(&apos;------------&gt;&gt;&gt;&gt; &apos;) p.apply_async(long_time_task, args=(i,)) print(&apos; wait for process done...&apos;) p.close() p.join() print(&apos;all progress done ..&apos;) 子进程 启动一个子进程 import subprocess print(&apos;$ nslookup www.python.org&apos;) r = subprocess.call([&apos;nslookup&apos;,&apos;www.python.org&apos;]) print(&apos;exit code &apos;, r) 进程间通信 进程间传递数据 from multiprocessing import Process,Queue import os,time,random # 写数据进程间执行代码 def write_data(q): print(&apos; pid :%s&apos; %os.getpid()) for value in [&apos;q&apos;,&apos;w&apos;,&apos;e&apos;,&apos;r&apos;]: print(value) q.put(value) time.sleep(random.random()) # 读数据进程间执行代码 def read_data(q): print(&apos; read pid : %s&apos; %os.getpid()) while True: value =q.get(True) print(&apos; 读取的数据 : &apos;+ value) if __name__ == &apos;__main__&apos;: # 父进程创建Quenu,并传递给子进程 q = Queue() pw = Process(target = write_data,args = (q,)) pr = Process(target = read_data,args =(q,)) pw.start() pr.start() pw.join() # pr 是死循环 无法等待其结束,只能强行终止 pr.terminate() 多线程 启动一个线程就是把一个函数传入并创建Thread实例,然后调用start()开始执行 # 创建一个线程,并执行 import time,threading # 新线程的代码 def loop(): print(&apos;线程%s is running ....&apos;%threading.current_thread().name) n =0 while n&lt;5: n=n+1 print(&apos;thread %s &gt;&gt;&gt; %s&apos;%(threading.current_thread().name,n)) time.sleep(1) print(&apos;线程%s is running ....&apos;%threading.current_thread().name) t =threading.Thread(target= loop,name= &apos;LoopThread&apos;) t.start() t.join() Lock 任何一个线程启动一个子线程,我们把该线程称为主线程 当多个线程共享一个变量并操作,导致内容错乱 使用lock.acquire(),当多个线程同时执行lock.acquire(),只有一个线程能成功获取锁,然后继续执行代码,其他线程就继续等待直到获得锁为止,获得锁的线程用完后一定要释放锁,否则会出现其他线程一直等待,成为死线程,所有使用try … finally 确保锁一定会被释放 ThreadLocal ThreadLocal 变量虽然是全局变量，但是每个线程都能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个参数之间互相传递的问题 import threading # 获取全局的ThreadLocal对象 local_school = threading.local() def process_student(): # 获取线程相关的student std = local_school.student print(&apos;hello ,%s(in %s)&apos;%(std,threading.current_thread().name)) def process_thread(name): # 绑定ThreadLocal的student local_school.student= name process_student() # 开启两个线程 t1 =threading.Thread(target= process_thread,args = (&apos;anakin&apos;,),name=&apos;Thread -a&apos;) t2 =threading.Thread(target= process_thread,args = (&apos;hahha&apos;,),name =&apos;Thread -b &apos;) t1.start() t2.start() t1.join() t2.join()","tags":[]},{"title":"自学Python-IO编程","date":"2017-01-13T01:30:18.000Z","path":"2017/01/13/自学Python-IO编程/","text":"读文件 使用open(‘文件地址’，’标识符’)函数 使用read()读取 最后一步使用close(关闭) 使用with读取，自动关闭 # 使用with 读取，自动关闭 with open(&apos;D:/pro/python/test.txt&apos;,&apos;r&apos;) as f: print(f.read()) 调用readline() 可以一次读取一行内容 调用readlines() 一次读取所有的内容，并返回一个list 不能确定文件大小使用readlines() with open(&apos;D:/pro/python/test.txt&apos;,&apos;r&apos;) as f: for line in f.readlines(): print(line.strip()) 读取二进制文件 打开模式使用’rb’ # 读取二进制文件 with open(&apos;D:/pro/python/img.png&apos;,&apos;rb&apos;) as f: for line in f.readlines(): print(line.strip()) 字符编码 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数 f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;) 遇到非法编码文件，open函数还接受一个errors参数，表示遇到编码错误后如何处理，最简单的方式就直接忽略 f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;,errors = &apos;ignore&apos;) 写文件 与读文件的区别open() 函数的的标识符，传入’w’,’wb’表示写文件和二进制文件 写文件 with open(&apos;D:/pro/python/write.txt&apos;,&apos;w&apos;) as f: f.write(&apos;hello write new file... &apos;) StringIO 和BytesIOStringIO很多时候，数据读写不一定是文件，也可以在内存中读写 在内存中写str，使用getvalue()获取写入的内容 from io import StringIO f = StringIO() f.write(&apos;hello&apos;) f.write(&apos;hello&apos;) f.write(&apos;hello&apos;) print(f.getvalue()) 读取StringIO while True: s =f.readline() if s ==&apos;&apos;: print(&apos;s ==&apos;+ s) break print(s.strip()) BytesIO 内存中读写二进制文件 # 写入二进制文件 from io import BytesIO f = BytesIO() f.write(&apos;你好&apos;.encode(&apos;utf-8&apos;)) s= f.getvalue() print(s) 读取二进制文件 # 读取二进制文件 from io import BytesIO f = BytesIO(b&apos;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&apos;) s= f.read() print(s) 操作文件和目录 查看当前目录的绝对路径 import os v= os.path.abspath(&apos;&apos;) # 查看当前目录的绝对路径 print(v) 在某个路径下创建一个新目录,首页把新路径目录表示出来 # 删除一个文件夹 os.rmdir(&apos;D:/pro/python/testdir&apos;) # 对文章重命名 a = os.rename(&apos;test.txt&apos;,&apos;test.py&apos;) #删除文件 d = os.remove(&apos;test.py&apos;) 过滤文件 # 过滤文件,比如列出当前目录下的所有文件夹 s = [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)] print(s) # 过滤文件 ,获得所有的.py文件 s = [ x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;] print(s) 序列化 我们把变量从内存中变成可存储的过程称为序列化序列化后的内容可以写到磁盘上或者通过网络传输 将对象序列化 import pickle d = dict(name=&apos;zhanghua&apos;,age=18,score=100) s =pickle.dumps(d) print(s) 将对象写入文件中 import pickle d = dict(name=&apos;zhanghua&apos;,age=18,score=100) s =pickle.dumps(d) print(s) f= open(&apos;dump.txt&apos;,&apos;wb&apos;) pickle.dump(d,f) f.close() 读取存储在文件中的对象 # 读取存储的对象 r= open(&apos;dump.txt&apos;,&apos;rb&apos;) o = pickle.load(r) r.close() print(o) JSON我们要在不同的编程语言中传递对象,就必须把对象序列化为标准格式,如xml 和json 序列化json和反序列化json import json # 序列化 d = dict(name=&apos;Bob&apos;,age=20,score=88) j = json.dumps(d) print(j) # 反序列化 json_str = &apos;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&apos; s =json.loads(json_str) print(s) 将实例对象序列化 class Student(object): def __init__(self, name,age,score): self.name = name self.age = age self.score = score s = Student(&apos;anakin&apos;,18,100) # 将实例转换为json j = json.dumps(s,default=lambda obj : obj.__dict__) print(j) json反序列化成对象 # json 反序列化成对象 def dict2student(d): return Student(d[&apos;name&apos;],d[&apos;age&apos;],d[&apos;score&apos;]) json_str = &apos;{&quot;score&quot;: 100, &quot;name&quot;: &quot;anakin&quot;, &quot;age&quot;: 18}&apos; r = json.loads(json_str, object_hook=dict2student) print(r)","tags":[]},{"title":"自学Python-Python基础.md","date":"2017-01-11T11:38:56.000Z","path":"2017/01/11/自学Python-Python基础/","text":"注释 以#开头作为注释右面的代码不会被执行 代码格式 语法比较简单,不同于java以分号作为结束,Python采用缩进的方式,所以代码格式非常重要 数据类型和变量数据类型 整数:可以处理任意大小的整数 浮点数 : 1.11, -3.15,,对于很大和很小的浮点数需要用科学计数法 注意:证书和浮点数在计算机内部存储方式是不同的,整数永远是精确的(除法也是精确的),浮点可能会四舍五入 字符串:以单引号或者双引号括起来的任意文本,”字符串”,’字符串’ boolean :一个布尔值只有True ,False两种值 注意大小写 空值:一个特殊的值None,不能理解为0 ,0是有意义的,None是一个特殊的空值 变量 变量不仅可以是数字,可说是任意数据类型,变量在程序中使用一个变量名表示,变量名必须符号命名规范 “=” 是赋值语句,表示把任意数据类型赋值给变量,同一个变量可以反复赋值,而且可以是不同类型的变量 eg:a= 123, a=’abc’ 这种变量本身不固定的语言称为动态语言,与之对应的静态语言比如java,定义变量时必须指定变量的数据类型,并且,一旦指定就不能被其他类型的变量赋值 常量 常量是不能改变的变量,比如数学中的常数π,就是一个常量,通常用全部大学表示常量 Python中的除法 / 10/3 = 3.33333333整数相除得到的结果是浮点数 // 10//3 =3 只取结果的整数部分","tags":[]},{"title":"自学Python-面向对象编程","date":"2017-01-11T11:38:56.000Z","path":"2017/01/11/自学Python-面向对象编程/","text":"类class Student(object): def __init__(self, name,score): self.name = name self.score = score def print_score(self): print(&apos;%s: %s&apos; % (self.name,self.score)) s1 = Student(&apos;anakin&apos;,18) s2 = Student(&apos;anran&apos;,18) s1.print_score() s2.print_score() 定义类以class开头,后买年跟类名,类名后面的括号中写继承的类(一般默认继承Object) 和普通函数相比,在类中定义函数,第一个变量永远是实例变量self,但是调用的时候不用传入,Python解释器会自动把实例变量传进去 数据封装 我们直接擦操作了对象内部数据,但无法知道方法内部的实现细节 访问限制 在Class内部,有属性和方法,而外部代码通过直接调用实例变量的方法来操作数据,这样就隐藏了内部的复杂逻辑 如果要想是内部属性不被外部访问,在属性名称前面加,在Python中如果变量名以开头,就变成了私有变量,只有内部可以访问,外部不能访问 不能被直接访问 class Student(object): def __init__(self, name,score): self.__name = name self.__score = score def print_score(self): print(&apos;%s: %s&apos; % (self.__name,self.__score)) s1 = Student(&apos;anakin&apos;,18) print(s1.__name); 外部如果想访问和修改实例的,可以通过get和set方法 class Student(object): def __init__(self, name,score): self.__name = name self.__score = score def print_score(self): print(&apos;%s: %s&apos; % (self.__name,self.__score)) def get_name(self): return self.__name def set_name(self,name): self.__name=name s1 = Student(&apos;anakin&apos;,18) print(s1.get_name()) s1.set_name(&apos;change&apos;) print(s1.get_name()); print(s1.print_score()) 注意 : 类似xxx_ ,双下划线开头,双下划线结尾属于特殊变量,特殊变量可以直接访问,所以在命名变量名的时候不要使用xxx 这样的变量名 类似_name的实例变量,外部是可以访问的,但是按照约定俗成的固定,这样的实例看作是私有的 继承 继承的好处,子类可以获得父类的全部功能 子类和父类存在同样的方法,这时我们说子类覆盖了父类的方法,运行时会调用子类的方法,这样我们就获得了继承的另外一个好处:多态 class Animal(object): def run(self): print(&apos;aninmal is running....&apos;) class Dog(Animal): def run(self): print(&apos;Dog is running....&apos;) class Cat(Animal): def run(self): print(&apos;Cat is running....&apos;) d = Dog() c = Cat() d.run() c.run() 多态 对于静态语言像java ,如果需要传入Anima类型,则传入的对象必须是Animal类型或者它的子类,否则无法调用run方法 对于动态语言想Python,则不一定要传入Animal类型,只需要保证传入的对象有一个run方法就可以了 动态语言的的”鸭子类型”,比要求严格的继承体系,一个对象只要”看起来像鸭子”,那它就可以被看作是鸭子. 获取对象信息 判断基本数据类型 s= type(&apos;123&apos;) print(s) 判断一个对象是否是函数,使用types提供的函数 import types &apos;判断对象是否是函数&apos; def fn(): pass s= types.FunctionType print(s) &apos;判断对象是否是函数&apos; def fn(): pass s= types.FunctionType s2 =types.BuiltinFunctionType s3 = type(abs)==s2 print(s3) print(s) isinstance()函数 &apos;isinstance()函数&apos; class Animal(object): pass class Dog(Animal): pass class Cat(Animal): pass a =Animal() d =Dog() c = Cat() s = isinstance(d,Animal) print(s) 判断是否是其中一种 s=isinstance([1,2,3],(list,tuple)) print(s) 使用dir() 获得一个对象的所有属性和方法使用dir() 配合使用getattr(),setattr(),hasattr(),可以直接操作一个对象的状态 class Animal(object): def __init__(self): self.x= 9 def power(self): return self.x*self.x a = Animal() s1 =hasattr(a,&apos;x&apos;) s2 =hasattr(a,&apos;y&apos;) s3 =getattr(a,&apos;x&apos;) s4 =setattr(a,&apos;x&apos;,4) s5= getattr(a,&apos;x&apos;) print(s1) print(s2) print(s3) print(s4) print(s5) 实例属性和类属性 Python是动态语言,根据类创建的实例可以绑定任意属性,可以删除 如果类中存在这个属性,绑定新的属性,会得到新绑定的属性,如果删除就得到类的属性,绑定的属性只能通过类的实例调用,不能通过类名获取","tags":[]},{"title":"自学Python-模块","date":"2017-01-11T09:35:35.000Z","path":"2017/01/11/自学Python-模块/","text":"使用模块标准注释 #!/usr/bin/env python3 # -*- coding: utf-8 -*- test_1.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- &apos;a test module&apos; ___author__=&apos;anakin&apos; import sys def test(): args = sys.argv if len(args)==1: print(&apos;hello,world&apos;) elif len(args)==2: print(&apos;hello :&apos;+ args[1]) else: print(&apos;too many argument!&apos;) if __name__==&apos;__main__&apos;: test() test_2.py import test_1 test_1.test() 作用域 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 #!/usr/bin/env python3 # -*- coding: utf-8 -*- &apos;函数的作用域&apos; ___author__=&apos;anakin&apos; def _private_1(name): print(&apos;private 1 run&apos;) def _private_2(name): print(&apos;private 2 run&apos;) def greeting(name): if len(name)&gt;3: return _private_1(name) else : return _private_2(name) 安装第三方模块 安装Pillow 安装Pillow pip install Pillow from PIL import Image im = Image.open(&apos;img.png&apos;) print(im.format,im.size,im.mode) 生成缩略图 im.thumbnail((200, 100)) im.save(&apos;thmb.jpg&apos;,&apos;JPEG&apos;)","tags":[]},{"title":"自学Python-函数式编程.md","date":"2017-01-11T06:01:12.000Z","path":"2017/01/11/自学Python-函数式编程/","text":"高阶函数 变量可以指向函数，函数的参数能接收变量，那么一个函数可以接收另一个函数作为参数，这种函数就称为高阶函数 变量可以指向函数 函数也是变量 传入函数 def add(x,y,f): return f(x)+f(y) s= add(2,3,abs) print(s) map/reducemap map 接收两个参数，一个函数，一个Iterabale,map将传入的函数依次祖作用到序列的每个元素，并把结果作为新的Iterator返回 def f(x): return x*x L=[1,2,3,4,5] m=map(f,L) s=list(m) print(s) 一个集合中的元素转换成字符串 m=map(str,[1,2,3,45]) s=list(m) print(s) reduce reduce的用法，把一个函数作用在一个序列[x1,x2,x3…],必须接&gt;收两个参数,return结果继续和序列的下一个元素做累积运算 from functools import reduce def fn(x,y): return x*10+y s=reduce(fn,[1,2,3,4]) print(s) filterfilter()函数用于过滤序列 和map()不同的是filter(),接收两个参数,一个函数和一个序列, &gt; 依次将函数作用序列的每一个元素,根据返回值是ture 还是false 决定保留还是丢弃该元素 筛选出奇数 def is_odd(n): return n%2==1 f =filter(is_odd,[1,2,3,4,5,6]) s = list(f) print(s) sorted 对list进行排序 s= sorted([1,2,3,53,21,0,3]) print(s) 可以接收一个key进行自定义排序 s= sorted([1,-2,-3,-53,21,0,3],key=abs) print(s) 根据字母顺序排列 L =[&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;] s =sorted(L,key=str.lower) print(s) 返回函数返回一个函数 def lazy_sum(*arg): def sum(): temp =0 for i in arg: temp = i+ temp return temp return sum f= lazy_sum(1,2,3,4) print(f) s = f() print(s) 总结 函数可以返回一个结果,也可以返回一个函数 返回函数时,函数并未执行,返回函数中不要应用任何可能会变化的变量 匿名函数匿名函数使用Lambda 表达式 L = [1,2,3,4] m = map(lambda x : x*x,L) s = list(m) print(s) 关键字lambda表示匿名函数,冒号前面的x就是参数 限制:只能有一个表达式,不用写retuen ,结果就为返回值 好处:不用担心命名冲突,可以把匿名函数赋值给一个变量,通过变量调用函数 同样,匿名函数也可以作为返回值返回 def build(x,y): return lambda:x*x+y*y f = build(1,2); print(f) 装饰器代码中*arg可变参数,**kw 关键字参数 def log(func): def wrapper(*arg,**kw): print(&apos;call :&apos;+func.__name__) return func(*arg,**kw) return wrapper @log def now(): print(&apos;print log&apos;) now() 偏函数import functools int2 = functools.partial(int,base=2) s =int2(&apos;10000&apos;) print(s) 当函数的参数太多需要简化时,functools.partial()创建一个新的函数,这个函数可以固定原函数的部分参数,是函数调用更简单","tags":[]},{"title":"代码示例","date":"2017-01-10T01:57:30.000Z","path":"2017/01/10/代码示例/","text":"package com.dy.dyth.base; import android.graphics.Bitmap; import android.graphics.Canvas; import android.graphics.drawable.Drawable; import android.support.v7.widget.RecyclerView; import android.view.KeyEvent; import android.view.View; import android.view.ViewGroup; import java.util.ArrayList; import java.util.List; /** * 创建者 demo * 创建时间 2016/7/26 16:48 * &lt;p&gt; * 更新者 $Author$ * 更新时间 $Date$ */ public abstract class BaseAdapter&lt;T&gt; extends RecyclerView.Adapter { private static final String TAG = &quot;BaseAdapter&quot;; public List&lt;T&gt; mDatas = new ArrayList&lt;&gt;(); public int layoutResId; public int layoutResIdtwo; //两种布局 public RecyclerView mRecyclerView; public BaseAdapter() { } public BaseAdapter(List&lt;T&gt; data, int layoutResId) { this.mDatas = data; this.layoutResId = layoutResId; } /** * 两种布局 * * @param data * @param layoutResId * @param layoutResIdtwo */ public BaseAdapter(List&lt;T&gt; data, int layoutResId, int layoutResIdtwo) { this.mDatas = data; this.layoutResId = layoutResId; this.layoutResIdtwo = layoutResIdtwo; } //设置回调监听 public interface OnFocusChange { void onFocusChangeListener(View v, boolean hasFocus, int position); } OnFocusChange mOnFocusChange; public void setOnFocusChange(OnFocusChange listener) { this.mOnFocusChange = listener; } //按键监听 public interface OnKey { void onKeyListener(View v, int keyCode, KeyEvent event, Object o, int position); } OnKey mOnKey; public void setOnKeyListener(OnKey listener) { this.mOnKey = listener; } // 长按 public interface OnLongClick { void onLongClickListener(View v, int position, Object bean); } OnLongClick mOnLongClick; public void setOnLongClickListener(OnLongClick listener) { this.mOnLongClick = listener; } //按下监听 public interface OnClick { void onClickListener(View v, int position, Object bean); } OnClick mOnClick; public void setOnClickListener(OnClick listener) { this.mOnClick = listener; } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { return initCreateViewHolder(parent, viewType); } protected abstract RecyclerView.ViewHolder initCreateViewHolder(ViewGroup parent, int viewType); @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, final int position) { final int itemPosition = holder.getLayoutPosition(); initBindViewHolder(holder, itemPosition); final Object bean = mDatas.get(position); //按下监听 if (mOnClick != null) { holder.itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mOnClick.onClickListener(v, itemPosition, bean); } }); } // 焦点监听 if (mOnFocusChange != null) { holder.itemView.setOnFocusChangeListener(new View.OnFocusChangeListener() { @Override public void onFocusChange(View v, boolean hasFocus) { mOnFocusChange.onFocusChangeListener(v, hasFocus, itemPosition); } }); } //长按监听 if (mOnLongClick != null) { holder.itemView.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View v) { mOnLongClick.onLongClickListener(v, itemPosition, bean); return true; } }); } //按键监听 if (mOnKey != null) { holder.itemView.setOnKeyListener(new View.OnKeyListener() { @Override public boolean onKey(View v, int keyCode, KeyEvent event) { mOnKey.onKeyListener(v, keyCode, event, bean, position); return false; } }); } } protected abstract void initBindViewHolder(RecyclerView.ViewHolder holder, int position); @Override public int getItemCount() { if (mDatas != null) { return mDatas.size(); } return 0; } /** * 解决当显示两张相同资源图片的时候，发生抖动，提高图片质量为Bitmap.Config.ARGB_8888 * * @param drawable 当前资源 * @return bitmap对象 */ private Bitmap drawableToBitmap(Drawable drawable) // drawable 转换成bitmap { int width = drawable.getIntrinsicWidth();// 取drawable的长宽 int height = drawable.getIntrinsicHeight(); Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);// 建立对应bitmap Canvas canvas = new Canvas(bitmap);// 建立对应bitmap的画布 drawable.setBounds(0, 0, width, height); drawable.draw(canvas);// 把drawable内容画到画布中 return bitmap; } }","tags":[]},{"title":"日常笔记","date":"2017-01-09T09:59:29.000Z","path":"2017/01/09/日常笔记/","text":"遇到的问题方法1 .使用mainup 解决左边不显示焦点框 2 .使用boderview 解决recyclerview 滑动中焦点的错位 3 .使用recylcerviewtv 控制焦点在中间 4 .recyclerview 显示左边复杂布局 选择方法 1 ， 3问题 了解框架 焦点框错位1. 焦点框图片 2. 计算方法 3. 布局文件问题 选择方法1. 布局问题 package com.dy.dyth.view; import android.content.Context; import android.support.annotation.Nullable; import android.support.v7.widget.RecyclerView; import android.util.AttributeSet; /** * Created by lph on 2016/8/17. * adapter TV */ public class TvRecyclerView extends RecyclerView { public TvRecyclerView(Context context) { this(context,null); } public TvRecyclerView(Context context, @Nullable AttributeSet attrs) { this(context, attrs,0); } public TvRecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); init(); } private void init(){ setChildrenDrawingOrderEnabled(true); } //设置当前选中条目显示在最前面 @Override protected int getChildDrawingOrder(int childCount, int i) { int currentPos = getChildAdapterPosition(findFocus()); if(i==childCount-1){ return currentPos; } if(i==currentPos){ return childCount - 1; } return super.getChildDrawingOrder(childCount, i); } } 问题首页焦点在滑动过程中错位####解决办法 #### 1. 修改本来布局 在layoutmanger中找到问题 2. 使用新的框架 分析1. 新框架需要改动的东西太多 2. 原有框架不明确出问题的地方 综合考虑1 .半天时间在原有框架上找出解决方法 2 .无法解决，则使用新的框架 ###超出边界分析 1. 为什么滑动的过程中会超出边界 1. recycler View 或者gridLyaoutManger 本身的问题 2. 或者 我自己布局的问题 解决方法 当滑动停止的时候 recyclerView 向右移动 使recyclerview的滑动不超过边界 原因确认 view放大没有超出边界 解决方法 手动当view获取焦点手懂控制recycler 向右移动10dp 头大 2016年9月5日09:51:14 问题 焦点框方法 修改布局 坚持一种方法 不要一直换 使用框架，了解基本用法 记住 clipToPadding就是说控件的绘制区域是否在padding里面的 clipChildren是指子控件是否超过padding区域 ###初始化显示焦点框## 隐藏不了 显示时间天气 wifi显示圆角图片 2016年9月7日10:56:09 待解决 页面切换焦点的问题 分类和首页item 在没有焦点的情况下隐藏焦点框 首页appinfo 按下鼠标下键的焦点切换 2016年9月9日 14:30:46 解决方法 在第三方库中找到焦点框的变化,设置显示影藏 2016年9月12日09:43:33 模拟网络请求显示图片 使用okhttp 使用rxjava 修改坑位命名 homekw_1; http://192.168.1.119:8080/home/home.json http://192.168.1.119:8080/home/kw1.png 解决打开app 应用崩溃的问题 2016年9月13日10:28:43 设置launcher 添加下面属性 &lt;category android:name=&quot;ansroid.intent.category.HOME&quot;/&gt; &lt;category android:name=&quot;ansroid.intent.category.DEFAULT&quot;/&gt;` 问题 ： 打开app后laucnher崩溃原因 ： bean中的Drawable没有序列化####解决办法#### 修改bean中的Bean 重写home中的app管理逻辑 360的实现方法 Bugly 日志:帐号:2014161860密码:dyth123456Bugly崩溃日志 : https://bugly.qq.com/issueIndex?app=900052943&amp;pid=1git命令：提交到远程服务器git remote add origin git@github.com:AnCorleone/TvVertiacalViewPager.git关联一个远程库 git remote rm origin // 添加错误清楚仓储 git push -u origin master //第一次推送master分支的所有内容 git push origin master //推送最新修改 同步代码 合并 解决冲突git fetch origin master:temp git merge temp 查看分支git branch Git忽略规则及.gitignore规则不生效的解决办法Git忽略规则及.gitignore规则不生效的解决办法 :http://www.pfeng.org/archives/840 解决打开app launcher崩溃2016年9月14日16:41:05 将Drawable 从bean 中移除 2016年9月18日13:51:15 monkey 测试adb shell monkey -p com.dy.dyth –-throttle 300 500 // monkey 测试命令 app 管理 卸载app 判断用户是否卸载成功2. 影梭购买地址 ：https://shadowsocks.com/ 服务器搭建 ： https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/ 服务器搭建(大胡子) :http://www.barretlee.com/blog/2016/08/03/shadowsocks/ 搬瓦工 :http://banwagong.cn/ 阿里服务器网址 ：https://account.aliyun.com/alipay/quick_login_return.htm?email=1018966939%40qq.com&amp;is_success=T&amp;notify_id=RqPnCoPT3K9%252Fvwbh3InWesh3oVFcSYEmWEsOrU6Ju2PrpgPSTlRM7rUmqTlV9kW%252F9%252B99&amp;real_name=%E5%BC%A0%E5%AE%89%E7%84%B6&amp;token=20160918d1f108c5face4ef69365c381a89a0X20&amp;user_id=2088602257446202&amp;sign=37548480cde2b1f14e73a5c3dc51220d&amp;sign_type=MD5 影梭指南 :http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/ 2016年9月19日 09:43:17 路线深圳 ——&gt; 南昌（10.1 5：13）——&gt;长沙 ——&gt; 武昌（10.1 9：31） ——&gt; 襄阳——&gt;南漳（签证） 电子地图 ：http://poi.mapbar.com/ 2016年9月20日09:42:44 安装和卸载软件更新界面 监听广播，有软件安装获取安装的软件信息，或者重新查询一遍获取所有的app重新加入集合 notify adapter 卸载软件 获取卸载的软件信息 ，从mall集合中移除或者重新查询，notify()问题 ： 安装软件空指针异常，软件崩溃 安装和卸载软件后焦点跑到home 上了 ，并显示了焦点框 adb pathadb path :C:\\DevTools\\Android\\Sdk\\platform-tools 脚本代码 ：@ECHO off @REM 无限循环的标签 :LOOP ECHO 请插入手机… adb wait-for-device @REM 循环安装本目录下的APK文件 FOR %%i IN (*.apk) DO ( ECHO 正在安装：%%i adb install &quot;%%i&quot; ) ECHO 安装完毕；请更换下一台手机！ PAUSE GOTO LOOP @ECHO on 9/21/2016 11:22:57 AM 问题 ：dialog dismiss 焦点跑到homeRecyclerView进行数据更新时焦点丢失的解决方案 : http://www.jianshu.com/p/749c0c91eb9c android:descendantFocusability=&quot;afterDescendants&quot; android:duplicateParentState=&quot;true&quot; 大数据优达学院 网址 :https://cn.udacity.com/ “我是一名码农,请尊重我的职业” 问题 ： notify后可以获取焦点，但不显示焦点框 9/22/2016 10:47:37 AM 问题 ：dilog 在卸软件卸载后弹出位置错位解决方法： 重新计算dilog 弹出的位置 x 轴计算问题 没有发现规律 可能是软件卸载后,布局跟新 微信公众平台 https://mp.weixin.qq.com/cgi-bin/home?token=511173594 问题 :app移动过程的bug解决方法: 调整移动的逻辑 9/23/2016 10:29:59 AM 问题 ：学籍注册移动的逻辑 ： 微信公众平台,小程序开发文档 :http://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432&amp;token=&amp;lang=zh_CN微信小程序： http://www.helloxcx.com/小程序api： http://wxopen.notedown.cn/ 9/24/2016 9:36:06 AM 显示网络错误的占位图片 Fresco 9/26/2016 9:47:03 AM 新建分类文件夹，显示预览效果 预览显示app icon从分类集合中获取显示，分类集合有多少显示多少 数据回显，存储info 到数据库中，并对每个分类添加分类的名字，根据类名查询该分类下的 所有信息 删除和替换，删除，从集合中删除，根据package name 从数据库删除 该app ； 替换：从集合中删除要替换的元素，并加入要替换的app ,从数据库中查找该分类删除该app，添加新的app info 9/27/2016 10:15:47 AM 分类页面展示app,数据的回显，删除和替换 回显数据的问题，初始化界面的是时候从sp 中获取集合mAddList，在adapter中显示，并添加一个空的待添加item,加到集合，每次点击添加，把添加的应用加到mAddList,把集合加到sp 中。 点击添加替换原来的坑位,增加一个坑位(在倒数第二个位置插入一个元素) 添加应用回显数据 添加到size-1 位置 ，notify 1. 替换回显会有问题2. 删除会回到主界面10/8/2016 9:55:34 AM 问题app 长按弹出 ,移动 ,卸载,替换,新建分类逻辑的实现解决卸载 替换 打开应用 数据回显 新建分类小程序教程网址http://www.helloxcx.com/article-20.php PAC 翻墙 https://www.seavia.com/share/iphone-ipad-mac-firefox-chrome-proxy.html 小米mini 路由翻墙https://seonoco.com/xiaomi-router-ss 问题app 移动和坑位焦点框出边界问题10/11/2016 9:14:51 AM android官网镜像网站 http://android.youdaxue.com/API 文档镜像 http://developer.android.youdaxue.com/guide/index.html优达Android基础视屏 https://classroom.udacity.com/courses/ud837/lessons/4027328704/concepts/43295507890923#Google 优达资源 https://discussions.youdaxue.com/t/android/84Google Play下载apk http://apps.evozi.com/apk-downloader 解决问题 App item 移动 理财平台 https://www.zhihu.com/question/24454597问题10/12/2016 10:34:49 AM app 移动dialog 没有一起移动 一个接口demo : http://www.jianshu.com/p/a28d4260a9d4View 的绘制流程 http://www.idtkm.com/customview/customview1/2016安卓开发资料大全 http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1007/6660.html#10/13/2016 11:23:27 AM 两步搞定Fragment的返回键 http://blog.csdn.net/lx448593jp/article/details/51121581 Android 中文文档 http://hukai.me/android-training-course-in-chinese/basics/index.html10/14/2016 3:08:34 PM 数据10/17/2016 4:56:51 PM 首页问题 替换没有问题 新建 卸载 移动 item 错乱 使用imageloader 加载图片 一切都可以被改变11/1/2016 10:11:35 AM 长记性 获取view的位置 https://my.oschina.net/u/1376187/blog/172792获取view的坐标系：http://blog.csdn.net/jason0539/article/details/42743531问题 1: 切换后来RecylerView 没有焦点框 11/4/2016 9:37:00 AM RecyclerView 局部刷新闪烁 http://wetest.qq.com/lab/view/176.html?from=content_zhihuzhuanlanGoogle 镜像站 http://xiaoyu2er.github.io/2016/03/16/google-mirror/问题1 : 删除一个分类后焦点框不在正确的位置显示 (上面一行最后一个)问题2 : 点击卸载,在弹出对话框的时候点击取消,或者返回,item放大正常不能缩小 ( 在弹出菜单时候设置的放大造成的影响)问题3 : 在移动过程中操作item 位置不对应 （ 操纵的是前一个bean ）问题4 : 卸载应用后新的item不能缩小问题 ：11/8/2016 11:19:03 AM 软件安装和卸载后焦点丢失 移动过程中的放大效果 问题11/10/2016 9:18:41 AM 卸载后相同的应用没有卸载 卸载失败，取消有放大效果 移动过程中放大异常 11/11/2016 3:54:01 PM 问题 : 新建文件夹的逻辑问题 ,移动后新建退出 焦点异常 问题 ：11/14/2016 10:19:52 AM 判断记录head 的view 还是记录recyclerView 的view ，当Head 有焦点的时候将position置为-1 ，当RecyclerView 有焦点的时候将Head view 置为null 问题 :11/15/2016 9:45:02 AM 记录焦点的view 如果记录view 不为空让记录的view获取焦点，如果为menu 就让menu获取焦点 menu 有焦点就显示光圈 没有先不显示 （没有问题了 ） 如果menu hasfocus 按上下键 重现的position 设置为 -1 ； 快捷键: ctrl + p 参数提示 ctrl + j 自动代码 ctrl + n 查找类 自定义接口回掉 定义一个接口 OnxxListener 接口中的方法 onXxx() 在需要的回调事件的类中声明接口对象 ， OnxxListener xxlistener ;定义回掉的方法 setOnxxListener(OnxxListener listenr) 将接口对象赋值给listener this.listenr =xxListener 在事件发生的位置调用接口中的方法 xxlistener. onXxx(); 知乎日报Apihttps://github.com/izzyleung/ZhihuDailyPurify/wiki/%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5-API-%E5%88%86%E6%9E%90 gank io API http://gank.io/apimvp 模式获取天气实例 http://rocko.xyz/2015/02/06/Android%E4%B8%AD%E7%9A%84MVP/http://www.jianshu.com/p/9a6845b26856gank demo : http://blog.csdn.net/castledrv/article/details/51396637 model entity impl view ui fragment activity presenter impl listener 一个API http://v3.wufazhuce.com:8000/api/hp/bymonth/20161125###http://119.29.116.107:8088/fmms/ ### http://rest.wufazhuce.com/OneForWeb/one/getHpinfo?strDate=2016-07-25问答 http://v3.wufazhuce.com:8000/api/question/1282文章 http://v3.wufazhuce.com:8000/api/essay/1339首页 http://v3.wufazhuce.com:8000/api/hp/idlist/0首页详情 http://v3.wufazhuce.com:8000/api/hp/detail/1275其他 ：http://v3.wufazhuce.com:8000/api/music/idlist/0http://v3.wufazhuce.com:8000/api/movie/list/0http://v3.wufazhuce.com:8000/api/movie/detail/%1http://v3.wufazhuce.com:8000/api/reading/index/http://v3.wufazhuce.com:8000/api/music/detail/%1原网址https://gist.github.com/0312birdzhang/6d2ed45457c908a0d290bing 每日图片 api http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1混淆 ： 5分钟搞定android混淆 http://blog.csdn.net/jdsjlzx/article/details/51853423 11/29/2016 10:27:39 AM 问题 页面切换，如果有选中item恢复焦点，左边menu会抢焦点 解决办法 页面显示的时候，如果记录的有item 就让让所有button 不能获取焦点，焦点移动到左边，需要button 获取焦点的时候，监听按键，使button可以获取焦点 当button 获取焦点的时候判断是否有item记录，如果有就让不显示焦点图片，没有则显示 问题 新建文件夹添加应用后，将首页显示的item移除 从分类中删除，在首页恢复显示 解决办法 getDatas setDatas 11/30/2016 9:11:11 AM重新运行程序的时候，应用列表会显示文件夹 问题： 重新运行程序的时候，应用列表会显示文件夹 重新运行程序的时候，应用列表会显示文件夹 解决办法 判断类型再加入到集合中 12/1/2016 2:47:38 PM CSDN 投票 http://blog.csdn.net/vote/candidate.html?username=lmj623565791 问题 最近使用 应用收藏解决办法 使用数据库存储数据 ORMLite 12/2/2016 11:38:11 AM 框架应用https://bng86.gitbooks.io/android-third-party-/content/greendao.htmlORMlite 怎删改查 http://www.cnblogs.com/alexthecoder/p/4277758.html 12/3/2016 5:46:06 PM 问题 按下menu键 弹出管理应用的菜单 将移动变为收藏 按下ok键 显示移动菜单 如果是上面一行，不显示向上移动，显示其他操作 如果是下面一行，不显示向下移动，显示其他操作 问题 按ok键弹出菜单，item 上下左右移动 但 12/7/2016 9:18:41 AM 组装配置 cpu i5 6500 1200 显卡 gtx1050 1299 主板 华硕B150M-A M.2 500 电源 全汉蓝暴450w 269 机箱 金河田预见N6 169 散热 九州玄冰智能版 49 硬盘 内存 金士顿120G固态 2999. 明年双11 ================= 3486 网盘搜索工具 http://panc.cc/问题 焦点框的放大 按下返回键，焦点丢失 问题 上下移动没有view没有放大效果 删除文件夹焦点错乱 新建文件夹错乱 替换焦点框错乱 弹出菜单消失,页面 12/9/2016 1:58:46 PM 招商银行卡号 6214 8378 0241 2118 12/12/2016 10:43:30 AM Android 官方课程http://hukai.me/android-training-course-in-chinese/ 12/15/2016 2:36:08 PM 重新写数据库 12/16/2016 11:11:40 AM 12/19/2016 5:10:29 PM流程图工具 亿图图示 :http://www.edrawsoft.cn/ 12/21/2016 9:59:43 AM 先进行移动操作，然后点击新建文件夹，分类会执行移动操作 adb shell am start -n com.dy.dyth/.ui.activity.LaunchActivity 问题 选择移动,再选择分类,然后返回,弹出框没有影藏 保存移动和插入的数据(移动的数序,和插入的分类) 移动item 选择分类,遥控器按返回 焦点丢失 问题 新建分类或者删除焦点错位 移动到最后一个返回键，焦点框丢失 12/26/2016 5:16:48 PM 问题 移动到后面 页面切换的恢复错误 移动 和分类的混乱 加入分类的应用从首页删除 问题 选择新建分类,不输入名字,点击确定,焦点框错位 在分类中增加应用,返回首页 ,焦点框丢失 替换只显示首页的应用(就是不包括已经添加到分类) 应用分类，替换应用替换掉的重新显示在首页，新的应用从首页删除 adb截图命令adb shell /system/bin/screencap -p /sdcard/image.png adb pull /sdcard/image.png c:\\dir 问题 数据库内存泄露 Monkey 命令adb shell monkey -v -p com.dy.dyth --monitor-native-crashes --throttle 500 10000 &gt;D:/7.22-RK_1.LOG adb shell monkey -v -p com.dy.dyth --monitor-native-crashes --throttle 300 10000&gt;D:/5.7-RK1.LOG adb shell monkey -v -p com.dy.dyth --monitor-native-crashes --throttle 300 5000 &gt;D:/NL1.LOG //优客超级直播 1万次测试 adb shell monkey -v -p com.dy.dyth --monitor-native-crashes --throttle 300 1000 ps | grep monkey // 获取monkey 端口 adb shell monkey -p com.dy.dyth –-throttle 300 5000 &gt;D:/DYTH.LOG set rw.sw.defaultlauncherpackage com.dy.dyth set rw.sw.defaultlauncherclass com.dy.dyth.LaunchActivity set rw.sw.settofirstlauncher 0 1/3/2017 3:44:11 PM - 用户卸载软件 从收藏和最近使用中删除 tiem : 2.5火车 2.4 号高铁 2.4 初八 问题1.按下菜单键 选择替换 选择点击返回,在按下菜单键,按下返回,焦点丢失 抢票时间 12.30 武汉到深圳 z 13.30 武汉到深圳 高铁 16：00 襄阳到深圳 z232 16:00 襄阳东到广州 z124 z232 搭建个人博客教程地址https://xuanwo.org/2015/03/26/hexo-intor/ 教程http://blog.fens.me/hexo-blog-github/ 我的博客地址@gmailhttps://anran0919.github.io/ @163 mailhttps://ancorleone.github.io/ github ipping username.github.io 域名 https://dcc.godaddy.com/manage/http://jiji262.github.io/2016/04/15/2016-04-15-hexo-github-pages-blog/Hexo更新博客命令hexo clean // 清空 hexo g // 生成静态网页 hexo s // 预览 hexo d // 更新到github hexo 主题 github链接 给博客添加相册 github链接 GitHub上最火的Android开源项目持续更新中……github最大的痛点在于，拿到开源项目不会用，导入各种报错，readme看不懂，推荐给大家一个链接，所有的 项目都亲测没有问题并且全部配置了详细的步骤和配套视频进行解说，欢迎大家star。","tags":[]},{"title":"Hello World","date":"2017-01-09T03:05:39.368Z","path":"2017/01/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]