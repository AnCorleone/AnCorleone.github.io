[{"title":"Android Fragment入门-AMS(ActivityManagerService)","date":"2017-06-01T09:46:10.000Z","path":"2017/06/01/Android-Fragment入门-AMS-ActivityManagerService/","text":"源码分析 Android framework层JNI的使用浅析 Android源码分析 c/c++学习 c语言入门教程","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"},{"name":"framework","slug":"framework","permalink":"http://anranz.com/tags/framework/"}]},{"title":"Android Material design使用","date":"2017-05-16T08:55:03.000Z","path":"2017/05/16/Android-Material-design使用/","text":"参考文章 MaterialDesignLibrary 掌握 Coordinator Layout","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"},{"name":"Material Design","slug":"Material-Design","permalink":"http://anranz.com/tags/Material-Design/"}]},{"title":"Windows+Ubuntu双系统安装","date":"2017-05-12T02:47:21.000Z","path":"2017/05/12/Windows-Ubuntu双系统安装/","text":"参考网址 Windows10+Ubuntu双系统安装[多图] 注意: 使用easybcd引导的时候使用grub2","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://anranz.com/tags/Ubuntu/"}]},{"title":"5.4 少年少年","date":"2017-05-04T03:46:28.000Z","path":"2017/05/04/5-4-少年少年/","text":"少年 ——扎西拉姆·多多 《少年，少年》 少年少年你仍然青涩如初吗？在我已经很斑驳的时候 少年少年你依旧纯然不动吗？在我漂泊了很久之后 少年少年你还相信美好吗？当我游走在这世道的窄口 少年你不能老去不能你要坚强的留在岁月的岸上那些沉重的、流离的和虚妄的都让我一个人去经历吧而你只需要穿着你的一身白衣让阳光照进你你要明媚的笑着等我满身风尘地回来认取","tags":[{"name":"随想","slug":"随想","permalink":"http://anranz.com/tags/随想/"}]},{"title":"Android使用RxJava获取U盘中的视频文件","date":"2017-04-05T07:28:30.000Z","path":"2017/04/05/Android使用RxJava获取U盘中的视频文件/","text":"前言前几天公司需要做一个播放视频的广告机,要求是插入U盘自动扫描视频文件,循环播放所有视频,后面增加需求做了开机启动,在遍历文U盘的文件夹时使用了RxJava,进行耗时操作,使用了线程调度,合并,遍历和转换和去重,第一次将RxJava使用到项目中,写下这篇博客,作为记录. Github地址: ADLoopVideoPlayer 环境 SDK:Android6.0 工具:Android Studio RxJavacompile &#39;io.reactivex:rxjava:1.0.14&#39;compile &#39;io.reactivex:rxandroid:1.0.1&#39; 设计模式:MVP模式 获取所有的视频文件 获取U盘跟目录下和根目录一级目录下的视频文件(需求是这样,不再遍历更深的目录). 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package com.anakin.adloopvideoplayer.model;import android.content.Context;import android.os.Environment;import com.anakin.adloopvideoplayer.presenter.OnVideoListener;import com.anakin.adloopvideoplayer.utils.AppUtils;import java.io.File;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeUnit;import rx.Observable;import rx.Subscriber;import rx.Subscription;import rx.android.schedulers.AndroidSchedulers;import rx.functions.Func1;import rx.schedulers.Schedulers;/** * Created by demo on 2017/4/2 0002 */public class VideoModel implements IVideoModel &#123; private List&lt;String&gt; mVideoInfos; private Subscription mSubscribe; @Override public void loadVideo(final OnVideoListener listener, final Context context) &#123; mVideoInfos = new ArrayList&lt;&gt;(); // 遍历根目录 File storage = new File(\"/storage\"); File[] files = storage.listFiles(); Observable&lt;File&gt; fileObservable = Observable.from(files) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.just(file); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; // 判断是可读USB目录 return file.canRead() &amp;&amp; !file.getName().equals(Environment.getExternalStorageDirectory().getName()); &#125; &#125;) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; // 遍历usb目录 @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;); Observable&lt;File&gt; file1 = fileObservable .filter(new Func1&lt;File, Boolean&gt;() &#123; //判断是文件夹 @Override public Boolean call(File file) &#123; return file.isDirectory(); &#125; &#125;) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; // 遍历文件夹 @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;); Observable&lt;File&gt; filter2 = fileObservable .filter(new Func1&lt;File, Boolean&gt;() &#123; //判断是文件 @Override public Boolean call(File file) &#123; return file.isFile(); &#125; &#125;); Observable&lt;String&gt; observable1 = filterFile(file1); Observable&lt;String&gt; observable2 = filterFile(filter2); mSubscribe = Observable.merge(observable1, observable2) .retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt;() &#123; @Override public Observable&lt;?&gt; call(Observable&lt;? extends Throwable&gt; observable) &#123; return observable.timer(3, TimeUnit.SECONDS); &#125; &#125;) .distinct() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; listener.onSuccess(mVideoInfos); &#125; @Override public void onError(Throwable e) &#123; listener.onFail(); &#125; @Override public void onNext(String s) &#123; mVideoInfos.add(s); &#125; &#125;); &#125; private Observable&lt;String&gt; filterFile(Observable&lt;File&gt; file) &#123; Observable&lt;String&gt; observable = file.filter(new Func1&lt;File, Boolean&gt;() &#123; // 过滤视频文件 @Override public Boolean call(File file) &#123; return AppUtils.isVideo(file.getAbsolutePath()); &#125; &#125;) .map(new Func1&lt;File, String&gt;() &#123; // 转换 返回文件路径 @Override public String call(File file) &#123; return file.getAbsolutePath(); &#125; &#125;); return observable; &#125; @Override public void unSubscribe() &#123; mSubscribe.unsubscribe(); &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://anranz.com/tags/RxJava/"}]},{"title":"Android视频播放","date":"2017-03-24T06:57:40.000Z","path":"2017/03/24/Android视频播放/","text":"参考文章 原生VideoView使用总结 循环播放视频","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"Ubuntu搭建Web开发环境","date":"2017-03-22T06:53:34.000Z","path":"2017/03/22/Ubuntu搭建Web开发环境/","text":"参考文章 Ubuntu Server搭建java web环境 Ubuntu搭建java开发环境 Ubuntu 16.04环境下安装myeclipse Ubuntu的Java开发环境基本搭建(JDK+IDE+Tomcat+MySQL+Navicat) Ubuntu安装JDK详解","tags":[{"name":"Java","slug":"Java","permalink":"http://anranz.com/tags/Java/"},{"name":"Web","slug":"Web","permalink":"http://anranz.com/tags/Web/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://anranz.com/tags/Ubuntu/"}]},{"title":"Android网络请求框架Rrtrofit的使用总结","date":"2017-03-22T01:33:54.000Z","path":"2017/03/22/Android网络请求框架Rrtrofit的使用总结/","text":"前言目录简单使用参考文章","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"Android图片加载库Glide的使用","date":"2017-03-20T09:12:14.000Z","path":"2017/03/20/Android图片加载库Glide的使用/","text":"前言Android中有不少的图片记载库,谷歌推荐使用Glide,Glide很强大,可以显示网络图片,本地图片,gif和本地vedio,Glide实现了多级缓存,提供了丰富的接口,使我们的图片加载变得很简单. 内容目录 简单使用 显示本地图片 显示网络图片 显示文件中的图片 加载gif图片和本地视频 使用占位符和错误图片 设置图片大小和显示缩略图 设置缓存和缓存优先级 自定义磁盘缓存 设置请求优先级 Glide Target回调 ViewTarget SimpleTarget NotificationTarget AppWidgetTarget Glide的监听和异常处理 自定义转换 - Custom Transformations 图片模糊处理 Glide 转换设置 Glide自定义动画 实现圆角图片和圆形图片 简单使用 在项目中添加依赖 Glide Github地址 compile &#39;com.github.bumptech.glide:glide:3.7.0&#39; 显示网络图片 1234String url = \"http://cn.bing.com/az/hprichbg/rb/TingSakura_ZH-CN14945610051_1920x1080.jpg\";Glide.with(this) .load(url) .into(img); 显示本地图片 1234Glide.with(this) .load(R.drawable.ic_launcher) .into(img);` 显示文件中图片 1234File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),\"Running.jpg\");Glide.with(this) .load(file) .into(img); 显示Gif和本地视频 显示gif 12345Glide .with(this) .load(gifUrl) //new GlideDrawableImageViewTarget() 第二个参数为gif 播放的次数 .into(new GlideDrawableImageViewTarget(img, 100)); 将gif转换成bitmap 12345Glide .with( context ) .load( gifUrl ) .asBitmap() .into( img ); 播放本地Video 12345String filePath = \"/storage/emulated/0/Pictures/example_video.mp4\";Glide .with(this) .load(Uri.fromFile(new File(filePath))) .into(img); 占位符和错误图片 添加占位符和错误图片 12345Glide.with(this) .load(url) .placeholder(R.mipmap.ic_launcher) // 占位图 .error(R.mipmap.ic_launcher) // 加载错误图片 .into(img); 设置图片大小和显示缩略图 调整图片大小 1234Glide.with(this) .load(url) .override(600,600) // 调整图片大小 .into(img); CenterCrop和FitCenter CenterCrop()是一个裁剪技术，即缩放图像让它填充到 ImageView 界限内并且裁剪额外的部分。ImageView 可能会完全填充，但图像可能不会完整显示。 FitCenter() 是裁剪技术，即缩放图像让图像都测量出来等于或小于 ImageView 的边界范围。该图像将会完全显示，但可能不会填满整个 ImageView。 CenterCrop 123456Glide .with(context) .load(url) .override(600, 200) // resizes the image to these dimensions (in pixel) .centerCrop() // this cropping technique scales the image so that it fills the requested bounds and then crops the extra. .into(imageViewResizeCenterCrop); FitCenter 1234567Glide .with(context) .load(url) .override(600, 200) .fitCenter() .into(imageViewResizeFitCenter); 缓存和请求优先级 Glide默认使用内存缓存和磁盘缓存，减少不必要的网络请求次数 跳过内存缓存 .skipMemoryCache( true ) 跳过磁盘缓存 .diskCacheStrategy( DiskCacheStrategy.NONE ) 自定义磁盘缓存 DiskCacheStrategy.NONE 什么都不缓存 DiskCacheStrategy.SOURCE 仅仅只缓存原来的全分辨率的图像。 DiskCacheStrategy.RESULT 仅仅缓存最终的图像，即，降低分辨率后的（或者是转换后的） DiskCacheStrategy.ALL 缓存所有版本的图像（默认行为） 12345Glide .with(this) .load(url) .diskCacheStrategy(DiskCacheStrategy.SOURCE) // 缓存原图 .into(img); 请求的优先级 当一个页面有多个图片，比如首页有一个大图，和若干小图，我们需要先将大图显示出来，这时候我们可以设置图片请求的优先级，控制不同图片的请求顺序,Glide提供了Priority ，选择不同的优先级 Priority.LOW Priority.NORMAL Priority.HIGH Priority.IMMEDIATE 示例代码： 1234567891011Glide .with( context ) .load( url1) // 大图优先加载 .priority( Priority.HIGH ) .into(img1);Glide .with( context ) .load(url2) .priority( Priority.LOW ) .into(img2); 显示缩略图 简单显示缩略图 12345Glide .with(this) .load(url) .thumbnail(0.1f) // 显示缩略图0.1f 代表原图的1/10 .into(img); 用完全不同的请求去请求缩略图 12345678DrawableRequestBuilder&lt;String&gt; request = Glide .with( this ) .load( url );Glide .with( this ) .load( url ) .thumbnail( request ) .into( img ); Glide Target回调 SimpleTarget 下面代码中创建一个SimpleTarget,Glide请求成功的图片会回调到SimpleTarget的方法中,可以对Bitmap 进行操作,也可以在SimpleTarget的构造函数中设置图片的大小 123456789101112SimpleTarget&lt;Bitmap&gt; simpleTarget = new SimpleTarget&lt;Bitmap&gt;(600,600) &#123; // 设置图片的大小,可选参数 @Override public void onResourceReady(Bitmap resource, GlideAnimation&lt;? super Bitmap&gt; glideAnimation) &#123; // 回调中获得Bitmap,可以根据需要对Bitmap进行操作 img.setImageBitmap(resource); &#125;&#125;;Glide .with(this) .load(url) .asBitmap() .into(simpleTarget); ViewTarget 使用ViewTarget实现自定义View显示图片 自定义view 123456789101112131415161718192021222324252627282930313233343536/** * Created by demo on 2017/3/21 0021 * 自定义view 显示图片和文字 */public class CustomView extends FrameLayout &#123; ImageView iv; TextView tv; public CustomView(Context context) &#123; super(context); initialize(context); &#125; public CustomView(Context context, AttributeSet attrs) &#123; super(context, attrs); initialize(context); &#125; public CustomView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initialize(context); &#125; public void initialize(Context context) &#123; inflate( context, R.layout.custom_view_futurestudio, this ); iv = (ImageView) findViewById( R.id.custom_view_image ); tv = (TextView) findViewById( R.id.custom_view_text ); &#125; public void setImage(Drawable drawable) &#123; iv = (ImageView) findViewById( R.id.custom_view_image ); iv.setImageDrawable( drawable ); &#125;&#125; 使用ViewTarget在自定义view中显示图片12345678910ViewTarget&lt;CustomView, GlideDrawable&gt; viewTarget = new ViewTarget&lt;CustomView, GlideDrawable&gt;(mCustomView) &#123; @Override public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) &#123; mCustomView.setImage(resource.getCurrent()); &#125;&#125;;Glide .with(this) .load(url) .into(viewTarget); 加载图片到通知栏和应用小部件 NotificationTarget 使用Notification 和 RemoteViews 以及常量 NOTIFICATION_ID,再加上NotificationTarget,就可以实现通知栏的图片显示. 示例代码: 12345678910111213141516171819202122232425262728293031323334353637383940private void initNotification() &#123; String url = \"http://cn.bing.com/az/hprichbg/rb/TingSakura_ZH-CN14945610051_1920x1080.jpg\"; final RemoteViews rv = new RemoteViews(this.getPackageName(), R.layout.notifycation); rv.setImageViewResource(R.id.remoteview_notification_icon, R.mipmap.pic062); rv.setTextViewText(R.id.remoteview_notification_headline, \"Headline\"); rv.setTextViewText(R.id.remoteview_notification_short_message, \"Short Message\"); android.support.v4.app.NotificationCompat.Builder builder = new NotificationCompat .Builder(this.getApplication()) .setSmallIcon(R.mipmap.pic062) .setContentText(\"content text\") .setContentTitle(\" content title \") .setContent(rv) .setPriority(NotificationCompat.PRIORITY_MIN); Notification notification = builder.build(); if (android.os.Build.VERSION.SDK_INT &gt;= 16) &#123; notification.bigContentView = rv; &#125; NotificationManager mNotificationManager = (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE); mNotificationManager.notify(NOTIFICATION_ID, notification); NotificationTarget notificationTarget = new NotificationTarget( this, rv, R.id.remoteview_notification_icon, notification, NOTIFICATION_ID); Glide .with(this.getApplicationContext() ) // safer! .load(url) .asBitmap() .into( notificationTarget ); &#125; AppWidgetTarget 使用AppWidgetTarget结合Glide显示应用小部件图片 代码实例: FSAppWidgetProvider.class12345678910111213141516171819202122232425262728293031public class FSAppWidgetProvider extends AppWidgetProvider &#123; private AppWidgetTarget appWidgetTarget; @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; super.onUpdate(context, appWidgetManager, appWidgetIds); String url = \"http://cn.bing.com/az/hprichbg/rb/TingSakura_ZH-CN14945610051_1920x1080.jpg\"; RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.custom_view_futurestudio); appWidgetTarget = new AppWidgetTarget( context, rv, R.id.custom_view_image, appWidgetIds ); Glide .with( context.getApplicationContext() ) // safer! .load(url) .asBitmap() .into( appWidgetTarget ); pushWidgetUpdate(context, rv); &#125; public static void pushWidgetUpdate(Context context, RemoteViews rv) &#123; ComponentName myWidget = new ComponentName(context, FSAppWidgetProvider.class); AppWidgetManager manager = AppWidgetManager.getInstance(context); manager.updateAppWidget(myWidget, rv); &#125;&#125; 需要在AndroidManifest中配置 123456789&lt;receiver android:name=\".glide_test.FSAppWidgetProvider\"&gt; &lt;meta-data android:name=\"android.appwidget.provider\" android:resource=\"@xml/appwidget_info\"&gt; &lt;/meta-data&gt; //引用的在res/xml下创建的文件 &lt;intent-filter&gt;//这个是接收广播时的过滤器 Android定义的 &lt;action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; appwidget_info.xml 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\" android:initialLayout=\"@layout/custom_view_futurestudio\" android:minHeight=\"40dp\" android:minWidth=\"100dp\" android:updatePeriodMillis=\"86400000\"&gt;&lt;/appwidget-provider&gt; Glide的监听和异常处理默认情况下，如果访问的图片出错，Glide会默默的抛出一个异常，如果设置了.error(),会显示配置的错误图片，如果需要明确知道异常的，或者想要对异常做一些处理，可以设置.listener(),监听图片的加载，你也可以在成功后做一些其他操作 监听glide加载图片 123456789101112131415161718RequestListener&lt;String, GlideDrawable&gt; requestListener = new RequestListener&lt;String, GlideDrawable&gt;() &#123; @Override public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123; // 发生异常时 return false; &#125; @Override public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; // 请求成功 return false; &#125;&#125;;Glide .with(this) .load(url) .error(R.mipmap.pic062) .listener(requestListener) .into(img); 自定义转换 - Custom Transformations为了实现自定义转换，我们需要实现 Transformation 接口，这个方法比较复杂，如果我们只是处理图片，是不是git或者video,使用BitmapTransformation抽象类可以满足我们的要求 使用转换实现模糊图像 代码示例： BlurTransformation.class1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.anakin.design_pattern_test.glide_test;import android.content.Context;import android.graphics.Bitmap;import android.renderscript.Allocation;import android.renderscript.Element;import android.renderscript.RenderScript;import android.renderscript.ScriptIntrinsicBlur;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;/** * Created by demo on 2017/3/21 0021 * 实现模糊图片 */public class BlurTransformation extends BitmapTransformation &#123; private RenderScript rs; public BlurTransformation(Context context) &#123; super(context); rs = RenderScript.create( context ); &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; Bitmap blurredBitmap = toTransform.copy( Bitmap.Config.ARGB_8888, true ); // Allocate memory for Renderscript to work with Allocation input = Allocation.createFromBitmap( rs, blurredBitmap, Allocation.MipmapControl.MIPMAP_FULL, Allocation.USAGE_SHARED ); Allocation output = Allocation.createTyped(rs, input.getType()); // Load up an instance of the specific script that we want to use. ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); script.setInput(input); // Set the blur radius script.setRadius(10); // Start the ScriptIntrinisicBlur script.forEach(output); // Copy the output to the blurred bitmap output.copyTo(blurredBitmap); toTransform.recycle(); return blurredBitmap; &#125; @Override public String getId() &#123; /** * Glide 使用该键作为缓存系统的一部分，为了避免意外的问题，你要确保它是唯一的。 */ return \"jjj\"; &#125;&#125; 使用转换：123456Glide .with(this) .load(url) .error(R.mipmap.pic062) .transform(new BlurTransformation(this)) .into(img); 运用多种转换 public DrawableRequestBuilder&lt;ModelType&gt; transform(BitmapTransformation... transformations) 可以接受多个参数，对图片进行多种转换 12345Glide .with( context ) .load( eatFoodyImages[1] ) .transform( new GreyscaleTransformation( context ), new BlurTransformation( context ) ) .into( imageView2 ); Glide 转换设置 设置起来很简单，对于基础版本你只需要在你当前的 build.gradle 中添加一行代码就可以了 123dependencies &#123; compile 'jp.wasabeef:glide-transformations:1.2.1'&#125; 如果你想要使用 GPU 转换： 123456789repositories &#123; jcenter() mavenCentral()&#125;dependencies &#123; compile 'jp.wasabeef:glide-transformations:1.2.1' compile 'jp.co.cyberagent.android.gpuimage:gpuimage-library:1.3.0'&#125; 如果你想使用 BlurTransformation,就添加下面这些代码到你的 build.gradle 中。 12345678android &#123; ... defaultConfig &#123; ... renderscriptTargetApi 23 renderscriptSupportModeEnabled true &#125;&#125; 使用BlurTransformation（jp.wasabeef.glide.transformations.BlurTransformation）,对图片进行模糊处理 示例代码： 1234567Glide .with(this) .load(url) .error(R.mipmap.pic062) // BlurTransformation(Context context, int radius, int sampling) .bitmapTransform(new BlurTransformation(this,25,1)) .into(img); Glide自定义动画Glide使用.animate（）可以使用xml创建的动画，也可以接收自定义的动画类 使用Android系统定义的动画xml 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"-50%p\" android:toXDelta=\"0\" android:duration=\"@android:integer/config_mediumAnimTime\"/&gt; &lt;alpha android:fromAlpha=\"0.0\" android:toAlpha=\"1.0\" android:duration=\"@android:integer/config_mediumAnimTime\" /&gt;&lt;/set&gt; 自定义动画xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:fillAfter=\"true\"&gt; &lt;scale android:duration=\"@android:integer/config_longAnimTime\" android:fromXScale=\"0.1\" android:fromYScale=\"0.1\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:toXScale=\"1\" android:toYScale=\"1\"/&gt;&lt;/set&gt; 自定义类实现动画 123456789ViewPropertyAnimation.Animator animationObject = new ViewPropertyAnimation.Animator() &#123; @Override public void animate(View view) &#123; view.setAlpha( 0f ); ObjectAnimator fadeAnim = ObjectAnimator.ofFloat( view, \"alpha\", 0f, 1f ); fadeAnim.setDuration( 2500 ); fadeAnim.start(); &#125;&#125;; 使用方法 12345678Glide .with(this) .load(url) .error(R.mipmap.pic062) .animate(animationObject) // 使用自定义的动画 // .animate(android.R.anim.slide_in_left) // 使用系统的xml动画 //.animate(R.anim.zoom_in) // 自定义的xml动画 .into(img); 实现圆角图片和圆形图片 实现原理是使用transform()对图片进行转换，自定义类GlideRoundTransform.class和GlideCircleTransform.class 实现圆形图片 GlideCircleTransform.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by demo on 2017/3/21 0021 * 实现原型图片转换 */public class GlideCircleTransform extends BitmapTransformation &#123; public GlideCircleTransform(Context context) &#123; super(context); &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; private Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; // TODO this could be acquired from the pool too Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return result; &#125; @Override public String getId() &#123; return getClass().getName(); &#125;&#125; 圆角图片转换 GlideRoundTransform.class 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Created by demo on 2017/3/21 0021 * Glide圆角图片转换 */public class GlideRoundTransform extends BitmapTransformation &#123; private static float radius = 0f; public GlideRoundTransform(Context context) &#123; this(context, 4); &#125; public GlideRoundTransform(Context context, int dp) &#123; super(context); this.radius = Resources.getSystem().getDisplayMetrics().density * dp; &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return roundCrop(pool, toTransform); &#125; private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight()); canvas.drawRoundRect(rectF, radius, radius, paint); return result; &#125; @Override public String getId() &#123; return getClass().getName() + Math.round(radius); &#125;&#125; 实现转换 12345678Glide .with(this) .load(url) .error(R.mipmap.pic062) .animate(animationObject) // 使用自定义的动画 //.transform(new GlideCircleTransform(this)) // 转换成圆形图片 .transform(new GlideRoundTransform(this,20)) // 转换成圆角图片 .into(img); 参考地址","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"焦虑","date":"2017-03-18T09:55:12.000Z","path":"2017/03/18/焦虑/","text":"所有的焦虑和迷茫，都是因为你太闲和太懒。 其实迷茫和焦虑并不可怕， 可怕的是你在迷茫和焦虑的过程中浪费了大把的「美好时光」","tags":[{"name":"随想","slug":"随想","permalink":"http://anranz.com/tags/随想/"}]},{"title":"使用RxJava实现EventBus(事件总线）","date":"2017-03-17T02:12:22.000Z","path":"2017/03/17/使用RxJava实现EventBus-事件总线）/","text":"口是心非的人，总是在夜里翻来覆去的。from 《电车计划》 使用事件总线可以使各组件的通信变的简单，实现功能代码的解耦，Android中流行的事件总线框架有otto和EventBus,当我们的工程中有使用RxJava的时候,可以使用RxJava实现EventBus,避免依赖过多的框架. 实现过程 创建一个RxBus类，编写单例方法 在构造函数中初始化Subject 创建发送事件的方法post(Object o) 创建接受事件的方法toObservable(Class klass),返回Observable 代码如下package com.anakin.design_pattern_test.rxbus_test; import rx.Observable; import rx.subjects.PublishSubject; import rx.subjects.SerializedSubject; import rx.subjects.Subject; /** * Created by demo on 2017/3/16 0016 */ public class RxBus { private static RxBus instance; private final Subject&lt;Object, Object&gt; bus; // 初始化Subject,PublishSubject只会把订阅的时间发生之后来自原始Observable的数据发送给观察者 // Subject 即是观察者也是被观察者 public RxBus() { bus =new SerializedSubject&lt;&gt;(PublishSubject.create()); } /** * 单例 * @return RxBus */ public static RxBus getInstance(){ if(instance==null){ synchronized (RxBus.class){ if(instance==null){ instance =new RxBus(); } } } return instance; } // 发送一个新事件 public void post(Object o){ bus.onNext(o); } /** * 接收事件 * @param klass 封装数据的实体类 * @param &lt;T&gt; * @return Observable */ public &lt;T&gt; Observable&lt;T&gt; toObservable(Class&lt;T&gt; klass){ return bus.ofType(klass); } } 使用// 接收事件 subscription= RxBus.getInstance().toObservable(EventBean.class) .subscribe(new Action1&lt;EventBean&gt;() { @Override public void call(EventBean eventBean) { Log.d(TAG,eventBean.toString()); // mResult.setText(eventBean.toString()); } } , new Action1&lt;Throwable&gt;() { @Override public void call(Throwable throwable) { // 接收异常 Log.d(TAG,throwable.toString()); //mResult.setText(throwable.toString()); } } ); 取消订阅事件注意一定要在生命周期被销毁的时候取消订阅事件,防止RxJava引起的内存泄露问题 @Override protected void onDestroy() { super.onDestroy(); // 取消订阅事件 if(!subscription.isUnsubscribed()) { subscription.unsubscribe(); } } 注 Subject既是观察者,也是被观察者 Subject是非线程安全的,所以要转换成SerializedSubject线程安全的 ofType()只发送符合类型的数据 PublishSubject只会把在订阅发生的时间点之后来自原始Observale的数据发送给观察者","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"Ubuntu16.04下载编译Android6.0源码","date":"2017-03-16T07:04:26.000Z","path":"2017/03/16/Ubuntu16-04下载编译Android6-0源码/","text":"一. 源码下载准备Git如果没有安装git,首先需要安装git,安装完成需要验证用户名的和邮箱 安装gitsudo apt-get install git 验证用户名和邮箱git config --global user.name &quot;your git name&quot;git config --global user.email &quot;you@example.com&quot; 安装curlsudo apt-get install curl 下载reporepo是google为方便管理android源码编写的一系列python脚本。 $ mkdir ~/bin $ PATH=~/bin:$PATH $ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo $ chmod a+x ~/bin/repo 同步代码 创建存放源码目录：mkdir android-6.0.1_r46cd android-6.0.1_r46 使用repo init指定要同步的代码版本。你可以在这里找到目前所有android源码的版本 : 选择源码版本 这里使用google的镜像服务器上同步代码，如果你没有翻墙工具或者下载很慢的话可以使用国内的源，比如清华的，像下面这样修改～/bin/repo中的REPO_URL。 REPO_URL = ‘https://gerrit-google.tuna.tsinghua.edu.cn/git-repo‘ 然后同样使用repo init来执行同步的版本 repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r46 开始同步代码 然后使用下面的命令下载源码。因为源码比较大，所以下载时间会很长，android6.0.1的代码大概有46G左右。repo支持断线重连，所以直接挂在哪里就可以了 repo sync 二. 编译源码三. 导入源码到Android Studio四. 刷入开发板参考文章Ubuntu16.04编译android6.0源代码从谷歌官网下载android 6.0源码、编译并刷入nexus 6p手机","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"RxJava--简单使用（二）","date":"2017-03-10T08:17:44.000Z","path":"2017/03/10/RxJava-简单使用（二）/","text":"subscribeOn 和 observeOn observeOn 可以调用多次进行线程的切换 一般情况下 subscribeOn 只能调用一次，可以在doOnSubscribe后调用，doOnSubscribe将运行在subscribeOn指定的线程 代码片段 .doOnSubscribe(new Action0() { @Override public void call() { // 运行在主线程 mProgressBar.setVisibility(View.VISIBLE); } }) .subscribeOn(AndroidSchedulers.mainThread()) 使用RxJava读取数据显示进度条 代码实现mSubscription = Observable.from(list) .flatMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() { @Override public Observable&lt;Integer&gt; call(Integer integer) { return Observable.just(integer); } }).filter(new Func1&lt;Integer, Boolean&gt;() { @Override public Boolean call(Integer integer) { // 模拟数据处理耗时 SystemClock.sleep(1000); int i = integer.intValue(); return i &gt; 222; } }) .map(new Func1&lt;Integer, String&gt;() { @Override public String call(Integer integer) { return integer.toString(); } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;String&gt;() { @Override public void onStart() { super.onStart(); mProgressBar.setVisibility(View.VISIBLE); } @Override public void onCompleted() { mProgressBar.setVisibility(View.INVISIBLE); tv.setText(result.toString()); } @Override public void onError(Throwable e) { System.out.println(&quot;Throwable::::&quot;+e.toString()); } @Override public void onNext(String s) { result.add(s); } });","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"RxJave和Retrofits的实现网络请求","date":"2017-03-08T06:14:32.000Z","path":"2017/03/08/RxJave和Retrofits的实现网络请求/","text":"Retrifit的使用 以获取豆瓣电影top250为例，使用Retrifit进行网络请求 网址 ： https://api.douban.com/v2/movie/top250?start=0&amp;count=10 添加依赖 compile &apos;com.squareup.retrofit2:retrofit:2.0.0-beta4&apos; compile &apos;com.squareup.retrofit2:converter-gson:2.0.0-beta4&apos; compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4&apos; compile &apos;com.google.code.gson:gson:2.6.2&apos; compile &apos;com.jakewharton:butterknife:7.0.1&apos; 网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 网络请求的接口 public interface MovieService { @GET(&quot;top250&quot;) Call&lt;MovieEntity&gt; getTopMovie(@Query(&quot;start&quot;) int start,@Query(&quot;count&quot;) int count); } 数据entity 创建数据对应的entity MovieEntity.class,部分代码 public class MovieEntity { public int total; public List&lt;SubjectsEntity&gt; subjects; public int count; public int start; public String title; .... } retrofit请求网络 String baseUrl = &quot;https://api.douban.com/v2/movie/&quot;; Retrofit retrofit = new Retrofit.Builder() .baseUrl(baseUrl) .addConverterFactory(GsonConverterFactory.create()) .build(); MovieService movieService = retrofit.create(MovieService.class); Call&lt;MovieEntity&gt; topMovie = movieService.getTopMovie(1, 10); topMovie.enqueue(new Callback&lt;MovieEntity&gt;() { @Override public void onResponse(Call&lt;MovieEntity&gt; call, Response&lt;MovieEntity&gt; response) { System.out.println(&quot;onResponse : &quot;+response.body().toString()); } @Override public void onFailure(Call&lt;MovieEntity&gt; call, Throwable t) { System.out.println(&quot;onFailure : &quot;+t.toString()); } }); 运行结果 MovieEntity{total=250, subjects=[SubjectsEntity{images=ImagesEntity{small=&apos;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p511118051.jpg&apos;, large=&apos;https://img3.doubanio.com/view/movie_poster_cover/lpst/public/p511118051.jpg&apos;, medium=&apos;https://img3.doubanio.com/view/movie_poster_cover/spst/public/p511118051.jpg&apos;}, casts=[CastsEntity{alt=&apos;https://movie.douban.com/celebrity/1025182/&apos;, name=&apos;让·雷诺&apos;, id=&apos;1025182&apos;, avatars=AvatarsEntity{small=&apos;https://img3.doubanio.com/img/celebrity/small/8833.jpg&apos;, large=&apos;https://img3.doubanio.com/img/celebrity/large/8833.jpg&apos;, medium=&apos;https://img3.doubanio RxJava和Retrofit实现网络请求 RxJava的使用可以参考上一篇文章RxJava-简单使用 首先还是添加依赖 compile &apos;io.reactivex:rxjava:1.1.0&apos; compile &apos;io.reactivex:rxandroid:1.1.0&apos; 修改gerMovieServer()代码将call改为observer @GET(&quot;top250&quot;) Observable&lt;MovieEntity&gt; getTopMovie(@Query(&quot;start&quot;) int start, @Query(&quot;count&quot;) int count); 修改网络请求的代码 String baseUrl = &quot;https://api.douban.com/v2/movie/&quot;; Retrofit retrofit = new Retrofit.Builder() .baseUrl(baseUrl) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); MovieService service = retrofit.create(MovieService.class); service.getTopMovie(1,1) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;MovieEntity&gt;() { @Override public void onCompleted() { System.out.println(&quot; onCompleted&quot;); } @Override public void onError(Throwable e) { info.setText(e.toString()); } @Override public void onNext(MovieEntity movieEntity) { info.setText(movieEntity.toString()); } }); 运行结果 参考: 参考地址","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"RxJava-简单使用","date":"2017-03-06T09:00:27.000Z","path":"2017/03/06/RxJava-简单使用/","text":"初识 异步:Rxjava 是一个实现异步操作的库 优点:随着逻辑的越来越复杂,他依然能够保持简洁 基于观察者模式 Observer(观察者,订阅者)Rxjava 提供的观察者接口:(一). observerObserver observer = new Observer() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(Object o) { } }; (二). subscriberSubscriber subscriber = new Subscriber() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(Object o) { } }; (三). 还支持不完整回调Action1&lt;String&gt; onNext = new Action1&lt;String&gt;() { @Override public void call(String s) { } }; Action1&lt;Throwable&gt; onError = new Action1&lt;Throwable&gt;() { @Override public void call(Throwable throwable) { } }; Action0 onComplete = new Action0() { @Override public void call() { } }; Observable observable = Observable.just(&quot;test&quot;); /** * 重载的方法 * 接收参数: * subscribe(final Action1&lt;? super T&gt; onNext, * final Action1&lt;Throwable&gt; onError, * final Action0 onComplete) */ observable.subscribe(onNext); observable.subscribe(onNext, onError); observable.subscribe(onNext, onError, onComplete); Observable (被观察者)创建方式 常规创建 Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { } }); 快速创建时间队,如: String [] items ={&quot;hello&quot;,&quot;RxJava&quot;}; Observable.from(items); Observable.just(&quot;接受&quot;,&quot;多个&quot;,&quot;参数&quot;); subscribe() (订阅)observable.subscribe(observer); // 或者： observable.subscribe(subscriber); Schedduler (线程控制) Schedduler 相当于线程控制器 ,指定每段代码运行在哪一个线程 内置的线程 Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 使用实例 以在io线程获取图片,并在ui线程显示图片 Observable.create(new Observable.OnSubscribe&lt;Drawable&gt;() { @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) { Drawable drawable = getResources().getDrawable(R.mipmap.pic subscriber.onNext(drawable); subscriber.onCompleted(); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Drawable&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { img.setImageResource(R.mipmap.ic_launcher); } @Override public void onNext(Drawable drawable) { img.setImageDrawable(drawable); } }); 变换 所谓变换就是将事件序列中的对象也可以是整个事件序列,进行加工处理,转换成不同的事件或者事件序列 map 使用实例，使用map对数据类型进行转换 Observable.just(R.mipmap.pic062) /** * 参数1:转换前数据类型 * 参数２：转换后的数据类型 */ .map(new Func1&lt;Integer, Drawable&gt;() { @Override public Drawable call(Integer integer) { return getResources().getDrawable(integer); } }) /** * 接收转换后的数据类型 */ .subscribe(new Action1&lt;Drawable&gt;() { @Override public void call(Drawable drawable) { img.setImageDrawable(drawable); } flatMap使用flatMap打印Student中的每个学生的选课的list元素 Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() { @Override public Observable&lt;Course&gt; call(Student student) { return Observable.from(student.getCourses()); } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Course&gt;() { @Override public void call(Course course) { System.out.println(&quot; call : &quot; +course.toString()); tv.setText(course.toString()); } }); 打印结果03-07 09:54:00.034 31125-31125/com.anakin.design_pattern_test I/System.out: call : Course{c_name=&apos;语文&apos;, id=111} 03-07 09:54:00.035 31125-31125/com.anakin.design_pattern_test I/System.out: call : Course{c_name=&apos;数学&apos;, id=222} scan 函数叠加器 操作符对Observable发射的第一项数据应用一个函数，然后将函数的结果作为自己的第一项数据发射 代码示例private void useScan() { Observable.just(1,2,3,4) .scan(new Func2&lt;Integer, Integer, Integer&gt;() { @Override public Integer call(Integer integer, Integer integer2) { return integer+integer2; } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer integer) { System.out.println(&quot; this is the result :&quot;+integer); } }); } 运行结果03-08 01:43:27.493 3674-3674/com.anakin.design_pattern_test I/System.out: this is the result :1 03-08 01:43:27.494 3674-3674/com.anakin.design_pattern_test I/System.out: this is the result :3 03-08 01:43:27.494 3674-3674/com.anakin.design_pattern_test I/System.out: this is the result :6 03-08 01:43:27.494 3674-3674/com.anakin.design_pattern_test I/System.out: this is the result :10 filter 过滤 符合条件的数据会被发射到subscriber private void useFilter() { Observable.just(1,2,3,4,5,6) .filter(new Func1&lt;Integer, Boolean&gt;() { @Override public Boolean call(Integer integer) { return integer&gt;2&amp;&amp;integer&lt;5; } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer integer) { System.out.println(&quot; filter result :&quot;+integer); } }); } 运行结果03-08 02:00:20.529 18136-18136/com.anakin.design_pattern_test I/System.out: filter result :3 03-08 02:00:20.529 18136-18136/com.anakin.design_pattern_test I/System.out: filter result :4 其他操作符 filter :集合进行过滤 each :遍历集合 take : take 取出集合中的前几个元素 skip : 跳过前几个元素 unique : 相当于数学中的集合去重 其他 添加到订阅和取消订阅 添加到订阅的方法 传入Observable 对象 private void addSubscription(Subscription subscribe) { if (mSubscription==null){ mSubscription=new CompositeSubscription(); } mSubscription.add(subscribe); } 取消订阅 @Override protected void onDestroy() { super.onDestroy(); if(mSubscription!=null){ mSubscription.unsubscribe(); } } 参考 给 Android 开发者的 RxJava 详解 吴小龙同学RxJava","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"Atom插件打造PHP开发平台","date":"2017-03-06T01:49:53.000Z","path":"2017/03/06/Atom插件打造PHP开发平台/","text":"在Ubuntu下安装Atom无须下载，可以通过命令直接安装： $ sudo add-apt-repository ppa:webupd8team/atom $ sudo apt-get update $ sudo apt-get install atom 安装好后，还需要安装一些插件把Atom打造成为PHP开发平台：linter：实时语法检查，保证代码语法正确性。 linter-csslint：CSS代码检查。 linter-jshint：Javascript代码检查。 linter-php：PHP代码检查。 minimap: 提供代码右侧的minimap。 vim-mode: 提供Vim编辑模式，不过只提供了命令模式和插入模式，遗憾的是还缺乏Vim的底线命令模式，这个硬伤有点大。 css-snippets：CSS代码模板。 javascript-snippets：Javascript代码模板。 jquery-snippets：jQuery代码模板。 symfony-snippets：Symfony代码模板。 drupal：Drupal代码模板。 web-browser：网站实时预览。 localization：菜单汉化 这些插件可以在Atom的插件管理工具里安装，也可以通过apm命令安装：$ apm install 插件名称","tags":[{"name":"PHP","slug":"PHP","permalink":"http://anranz.com/tags/PHP/"},{"name":"Atom","slug":"Atom","permalink":"http://anranz.com/tags/Atom/"}]},{"title":"不忘初心","date":"2017-03-02T02:41:44.000Z","path":"2017/03/02/不忘初心/","text":"一个人知道自己为什么而活, 就可以忍受任何一种生活. 为了受过的嘲笑, 为了幸劳的父母, 为了儿女有更好的生活.","tags":[{"name":"随想","slug":"随想","permalink":"http://anranz.com/tags/随想/"}]},{"title":"三月","date":"2017-03-01T07:38:43.000Z","path":"2017/03/01/三月/","text":"爱情本就是一场关于你的信仰。 爱你想爱的， 追随你甘心追随的。 其余的， 就交给时间。","tags":[{"name":"随想","slug":"随想","permalink":"http://anranz.com/tags/随想/"}]},{"title":"桥接模式.md","date":"2017-02-28T06:27:59.000Z","path":"2017/02/28/设计模式-桥接模式/","text":"桥接模式桥接是用于把抽象化和实例化解耦，使二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实例化之间的桥接结构，来实现二者解耦。 使用实例 画不同圆形，包括半径和x,y,可以添加不同的实现类定制圆形的颜色,在调用方法传入不同的参数,定制圆形的半径和其他坐标参数 实现过程: 定义一个画图的接口DrawApi，包含一个drawCircle(int radius,int x,int y)方法 定义一个Shape的抽象类,包含一个draw()方法,构造函数接受DrawApi的实例 分别定义一个画RedCircle和GreenCircle的类,实现DrawApi接口 定义一个Circle类,继承shape类,构造函数接受drawCircle(int radius,int x,int y)需要的参数,实现draw()方法,在方法中调用drawCircle()方法 最后new Circle(),接受DrawApi的实例,传入所需参数 原理分析只要解决一种事物的多种可能性,如实例图形的形状,颜色,半径,实例中要画两种不同的圆形,首先在圆形具体类Circle中继承Shape类,在Shape类中获取操作图形参数的接口DrawApi实例,并在draw 方法中调用DrawApi的方法,所需参数需要DrawApi的实例,和具体的并在draw 的参数,由调用者传入具体的参数 调用过程DrawApi的实例(如:不同颜色的圆形 ) –Shape的实例(构造方法传入半径,坐标) –&gt;实例中调用DrawApi的方法,传入获得的参数,实际调用的DrawApi实例的方法,参数在Shape中传入 在一个特性中获取另一个特性的实例，并把这个实例的参数传入到另一特性中 代码如下:定义DrawApi接口 public interface DrawApi { void drawCircle(int radius,int x,int y); } 定义Shape抽象类 public abstract class Shape { DrawApi mDrawApi; public Shape(DrawApi drawApi) { mDrawApi = drawApi; } public abstract void draw(); } 定义不同颜色圆形的实现类,实现DrawApi接口 public class GreenCircle implements DrawApi { @Override public void drawCircle(int radius, int x, int y) { System.out.println(&quot; 画一个绿色的圆形 &quot;+&quot;radius:&quot;+radius+&quot;x :: &quot;+ x+&quot; y ::&quot;+y); } } 定义Circle继承Shape类 public class Circle extends Shape { private int radius; private int x; private int y ; public Circle(DrawApi drawApi, int radius, int x, int y) { super(drawApi); this.radius = radius; this.x = x; this.y = y; } @Override public void draw() { mDrawApi.drawCircle(radius,x,y); } } 测试调用 DrawApi gc,rc; gc = new GreenCircle(); // 画绿色的圆 rc =new RedCircle(); // 画红色的圆 Shape circle = new Circle(gc, 10, 3, 4); //绿色的圆 设置半径和坐标参数 circle.draw(); // 作图 Shape circle2= new Circle(rc,20,6,8); //红色的圆 设置半径和坐标参数 circle2.draw(); // 作图 测试结果 02-28 05:22:51.529 28053-28053/com.anakin.design_pattern_test I/System.out: 画一个绿色的圆形 radius:10x :: 3 y ::4 02-28 05:22:51.530 28053-28053/com.anakin.design_pattern_test I/System.out: 画一个红色的圆形 radius:20x :: 6 y ::8","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://anranz.com/tags/设计模式/"}]},{"title":"怎样选择基金","date":"2017-02-22T03:41:02.000Z","path":"2017/02/22/怎样选择基金/","text":"一. 看收益 两年中排名前十位 同类排名靠前 超过同类平均 二.看波动(波动率) 看最大回馈 晨星评级 三.看投向 谨慎选择房地产，创业板中小板（重仓持股） 四.看基金经理 尽量一年以上，无频繁更换 五.基金公司 从大公司中选择 参考地址","tags":[{"name":"理财","slug":"理财","permalink":"http://anranz.com/tags/理财/"}]},{"title":"Vim基本操作","date":"2017-02-22T03:33:14.000Z","path":"2017/02/22/Vim基本操作/","text":"vim的基本操作 在普通模式.重复上一次操作 执行制定次数相同的命令 游标的快速跳转 行间跳转 : nG表示跳转到地n行 gg游标移动到第一行 G跳转到行尾 ctrl 回到游标跳转前的位置 复制粘贴和剪切 复制和粘贴文本 yy表示复制整行 yw：复制一个单词 y$复制到行尾 y^复制到行头 y^复制到行头 字符替换及撤销操作 r替换光标所在的字母 R 连续替换，直到按下esc cc替换整行,进入插入模式 cw替换一个单词，进入插入模式 u{n}撤销一次或者n次操作 ctrl+r恢复撤销的操作 快速缩进 &gt;&gt; 整行向右缩进 &lt;&lt; 整行向左缩进 命令行模式输入ce是选中的行的内容居中 查找 普通模式使用/向下查找 ?向上查找 n 表示继续查找 使用vim编辑多个文件 命令模式输入n编辑下一个文件 N编辑上一个文件，加! 强制进行切换 进入vim打开新文件，同时编辑多个文件，在命令模式下输入e：文件名 e#回到前一个打开的文件 ls可以列出编辑过的文档 恢复文件 使用vim -r 打开文件 输入:ewcover 文件名来恢复 打开新窗口 命令模式下输: new","tags":[{"name":"Vim","slug":"Vim","permalink":"http://anranz.com/tags/Vim/"}]},{"title":"文件操作的工具类","date":"2017-02-22T03:04:08.000Z","path":"2017/02/22/文件操作的工具类/","text":"判断文件类型 判断打开方式 Android中对多媒体文件的打开操作，图片，视屏，音乐，文本 判断文件类型package com.dy.explorer.utils; /** * 获取文件的类型 */ public class TypeUtils { public static boolean isTxt(String name){ if(name.endsWith(&quot;.txt&quot;)||name.endsWith(&quot;.log&quot;)||name.endsWith(&quot;.rtf&quot;)||name.endsWith(&quot;.conf&quot;)||name.endsWith(&quot;.xml&quot;)){ return true; } return false; } public static boolean isImage(String name){ if(name.endsWith(&quot;.jpg&quot;)||name.endsWith(&quot;.png&quot;)||name.endsWith(&quot;jpeg&quot;)){ return true; } return false; } public static boolean isVideo(String name){ if(name.endsWith(&quot;.mp4&quot;)||name.endsWith(&quot;.avi&quot;)||name.endsWith(&quot;.flv&quot;)||name.endsWith(&quot;.rmvb&quot;)||name.endsWith(&quot;wmv&quot;)||name.endsWith(&quot;.mkv&quot;)||name.equals(&quot;.mov&quot;)||name.endsWith(&quot;.mpeg&quot;)||name.endsWith(&quot;mpg&quot;)) {return true;} return false; } public static boolean isAudio(String name){ if(name.endsWith(&quot;.mp3&quot;)||name.endsWith(&quot;wav&quot;)||name.endsWith(&quot;.wma&quot;)||name.endsWith(&quot;.midi&quot;)){ return true; } return false; } } 判断打开方式if(TypeUtils.isImage(file.getName())){ OperationUtils.openPhoto(file.getAbsolutePath()); }else if(TypeUtils.isAudio(file.getName())){ OperationUtils.openAudio(file.getAbsolutePath()); }else if(TypeUtils.isVideo(file.getName())){ OperationUtils.openVideo(file.getAbsolutePath()); } 打开文件package com.dy.explorer.utils; import android.content.Intent; import android.net.Uri; import android.widget.Toast; import java.io.File; /** * 对文件进行操作的工具类 */ public class OperationUtils { public static void openTxt(String path) { try { // text/plain Uri uri = Uri.parse(path); Intent intent = new Intent(Intent.ACTION_VIEW); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setDataAndType(uri, &quot;text/plain&quot;); UiUtils.getContext().startActivity(intent); } catch (Exception ex) { Toast.makeText(UiUtils.getContext(), &quot;系统没有安装打开该文件的应用&quot;, Toast.LENGTH_SHORT).show(); } } /** * 打开视频 * * @param path */ public static void openVideo(String path) { Uri uri = Uri.parse(path); Intent intent = new Intent(Intent.ACTION_VIEW); intent.setDataAndType(uri, &quot;video/mp4&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); UiUtils.getContext().startActivity(intent); } /** * 打开图片 * * @param path */ public static void openPhoto(String path) { Intent intent = new Intent(Intent.ACTION_VIEW); intent.setDataAndType(Uri.fromFile(new File(path)), &quot;image/*&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); UiUtils.getContext().startActivity(intent); } /** * 打开音频文件 * * @param absolutePath */ public static void openAudio(String absolutePath) { Intent intent = new Intent(); intent.setAction(android.content.Intent.ACTION_VIEW); Uri uri = Uri.parse(&quot;file:&quot; + absolutePath); intent.setDataAndType(uri, &quot;audio/*&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); UiUtils.getContext().startActivity(intent); } }","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"模版模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-模版模式/","text":"##模版模式 定义 :定一个操作中的算法框架,而将一些步骤延迟到子类中,使子类不用改变算法的结构重新定义算法中的步骤. 使用场景 多个子类共有方法并且逻辑基本相同 重要,复杂的核心算法,可以把核心算法设计成模版方法,周边的具体细节由子类去实现 重构时,将相同的代码抽取到父类中,然后通过子函数约束其行为 使用示例 以电脑开机为例,基本过程相同,不同的电脑具体细节不同 开机的父类定义模版方法,调用开机的过程 package com.anakin.design_pattern_test.demo.singel_instance.templatemethod; /** * Created by demo on 2017/2/8 0008 */ public abstract class OpenComputer { public void loadOs() { System.out.println(&quot;加载系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } public void checkHardware() { System.out.println(&quot;检查防火墙&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } public void powerOn() { System.out.println(&quot;连接电源&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } public void login() { System.out.println(&quot;验证登录系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } public final void startUp(){ System.out.println(&quot;=========== open start ============&quot;); powerOn(); checkHardware(); loadOs(); login(); System.out.println(&quot;=========== open end ============&quot;); } } 以程序员的电脑和军人的电脑开机为例,程序在登录的时候需要输出密码,而军人的电脑在开机的过程中需要检查防火墙 程序员的电脑 package com.anakin.design_pattern_test.demo.singel_instance.templatemethod; /** * Created by demo on 2017/2/8 0008 */ public class CoderComputer extends OpenComputer { @Override public void login() { // super.login(); System.out.println(&quot; ......... coder&apos;s computer open login &quot;); } } 军人的电脑 package com.anakin.design_pattern_test.demo.singel_instance.templatemethod; /** * Created by demo on 2017/2/8 0008 */ public class MilitaryComputer extends OpenComputer { @Override public void checkHardware() { System.out.println(&quot; military&apos;s is check haedware !!!!!!!!!!!&quot;); } } 测试 // 模版模式测试 OpenComputer coderPc = new CoderComputer(); coderPc.startUp(); OpenComputer militaryPc = new MilitaryComputer(); militaryPc.startUp(); 测试结果 02-08 08:53:19.246 3221-3221/com.anakin.design_pattern_test I/System.out: =========== open start ============ 02-08 08:53:19.246 3221-3221/com.anakin.design_pattern_test I/System.out: 连接电源&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.246 3221-3221/com.anakin.design_pattern_test I/System.out: 检查防火墙&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.246 3221-3221/com.anakin.design_pattern_test I/System.out: 加载系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.247 3221-3221/com.anakin.design_pattern_test I/System.out: ......... coder&apos;s computer open login 02-08 08:53:19.247 3221-3221/com.anakin.design_pattern_test I/System.out: =========== open end ============ 02-08 08:53:19.247 3221-3221/com.anakin.design_pattern_test I/System.out: =========== open start ============ 02-08 08:53:19.247 3221-3221/com.anakin.design_pattern_test I/System.out: 连接电源&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.248 3221-3221/com.anakin.design_pattern_test I/System.out: military&apos;s is check haedware !!!!!!!!!!! 02-08 08:53:19.248 3221-3221/com.anakin.design_pattern_test I/System.out: 加载系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.248 3221-3221/com.anakin.design_pattern_test I/System.out: 验证登录系统&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 02-08 08:53:19.253 3221-3221/com.anakin.design_pattern_test I/System.out: =========== open end ============","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://anranz.com/tags/设计模式/"}]},{"title":"Java设计模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/Java设计模式/","text":"设计原则1.单一职责原则 : 一个类只负责一个功能领域中的相应职责 2. 开闭原则 : 一个软件实体应当对扩展开放，对修改关闭 3. 里氏代换原则 : 所有应用基类（父类）的地方，必须能透明的使用其子类对象 使用原则 : 在程序设计时,尽量使用基类类型对对象进行定义,而在运行时再确定子类类型,用子类对象替换父类对象 4. 依赖倒转原则 抽象不应该依赖于细节,细节应当依赖于抽象.换言之就是,要面向接口编程,而不是针对实现编程. 程序代码中传递参数或关联关系时,尽量应用层次高的抽象层类,既使用抽象类,接口进行变量类型声明,参数声明,返回值类型声明,以及数据类型的转换等,而不要用具体的类来做这些事.","tags":[]},{"title":"MySql的修改和删除.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/MYSQL的修改和删除/","text":"数据库的修改和删除 打开数据库 ‘sudo service mysql start’ 登录数据库 ‘mysql -u root -p’ 查看数据卡 show databsaes 删除数据库 drop databsaes 数据库名 连接数据库 use 数据库名 显示数据库中的表 show tables 查看表中的类容 select * from 表名 修改表的名字 rename table 旧表名 to 新表名 删除一张表 drop table 表名 增加列 alter table 表名 add column 列名字 数据类型 约束 eg: alter table employee add height int(4) default 170 (给employee 表增加height列 ) 增加列并指定新增列的位置 使用after eg: alter table employee add height int(4) dafault 170 after age ; 新增加列放在第一个使用 first 删除一列 alter table 表名 drop column 列名字 修改表中的某个值 update 表名 set 列1=值1，列2=值2 where 条件 eg: update employee set age=24,salary=300 where name = ‘Tom’ 根据条件删除一列 delete table from employee where name=’Tom’; 索引 增加索引 create index 索引名字 on 表名（列名）eg : create index idx_id on employee(id) 视图视图是从一个或多个表中取出数据在窗口中展示，可以看作一张表，但数据依赖原表 创建视图的语句: create view 视图名字（列a,列b，列c) as select 列1,列2,列3 from 表名eg : create view v_emp(v_name,v_age,v_salary) as select name,age,salary from employee; 导入 把文件中的数据导入表中 导入语句格式 load data infile ‘文件路径’ to 表名eg: load data infile ‘/home/anakin/MySql/SQL6/in.txt’ to employee 导出 将表中的数据导出到文本中 导出的语句格式：select name,age into outfile ‘文件路径和文件名’ from 表名eg : select * into outfile ‘/tmp/out.txt’ from employee 数据库备份 使用mysqldump备份数据库，生成sql脚本文件 备份整个数据库 mysqldump -u root 数据库名&gt;备份文件名 备份数据表 mysqldump -u root 数据库名 表名&gt;备份文件名 eg : mysqldump -u root -p mysql_shiyanlou&gt;bak.sql; 数据库恢复 恢复数据的语句： 使用source sql 脚本 新建一个数据库 create database test; 恢复数据 mysqldump -u root -p test&lt;bak.sqp","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://anranz.com/tags/MySQL/"}]},{"title":"观察者模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-观察者模式/","text":"观察者模式实现过程 观察者模式基本组成是，观察者Observer和被观察者（观察目标）Subject,当目标发生改变的时候，观察者会随之改变 一个被观察者可以被多个观察者观察 被观察者一般提供一个集合保存观察者，提供对观察者的管理，删除和增加观察者，提供一个抽象的notify方法，由具体的被观察者实现，实现方式为，遍历观察者的集合，调用观察者的update()方法，通知每一个观察者 观察者申明为一个接口，一般提供update()方法，由不同的观察者去实现，具体的观察者在接收到观察者的notify()后做出相应的更新 要点 观察者提供update()方法，在update()方法中变量观察者的集合，调用观察者的update()方法 一般定义被观察者为抽象类提供管理观察者的方法，和抽象的notify()方法 一般将观察者声明为接口，提供update()方法，由具体的观察者去实现，根据需要对被观察者的改变做出不同的实现 实例 背景： 以游戏为例，多人组队玩一个游戏，当有一个人遭受攻击时向控制中心发消息，控制中心收到消息通知每个队友，队友收到消息过来支援 每个队员都作为观察者，被观察者为控制中心 当有队员Player受到攻击时，调用控制中心的notifyObsever() 方法，在notifyObsever()方法中遍历观察者也就是所有队员，会调用所有队友的help() 方法 代码过程 观察者的接口 ：观察者的接口Observer 申明了help（），beAttached()方法 具体的观察者 ：具体的观察者Player类，实现接口中的方法 被观察者抽象类 ：被观察者抽象类AllyControlCenter,包括对观察的管理的集合和join()和quit()方法，和通知每个观察者的抽象方法notifyObsever()方法， 被观察者 ：被观察者的实现类ConcreteAllyControlCenter ，是先notifyObsever()方法，遍历观察者集合，调用每个人观察者对象的help()方法 客户端 ：创建观察者对象Observer player = new Player()，创建被观察者实例AllyControlCenter ally = new ConcreteAllyControlCenter();，将观察者加入到集合中， all.join(Player),player调用beAttached(),所有观察者收到消息调用help()方法，（当被观察者触发beAttached() 方法时候，在beAttached()中调用notifyObsever() 方法通知每个观察者调用help()方法） 代码调用流程 player.beAttached()—–&gt; AllyControlCenter.notifyObsever()—-&gt; player.help()","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://anranz.com/tags/设计模式/"}]},{"title":"简单工厂模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-简单工厂模式/","text":"## 简单工厂模式 定义抽象的工厂类 工厂类包定义公共的方法实现，和不同实现的抽象方法 定义根据参数创建实例对象，返回抽象类的静态方法 使用静态方法传入要获取对象的tag,获取对象的实例，调用实例的方法","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://anranz.com/tags/设计模式/"}]},{"title":"MySQL基本操作.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/MySQL进阶-操作详解/","text":"MySQL基本操作 打开数据库 sudo service mysql start; 连接数据库 mysql -u root -p 查看数据库 show dabases 使用数据库 use 数据库名字 创建数据库 create database 数据库名 eg : create database test 创建表 create table 表名（列名 数据类型 约束）eg : create table pet(name VARCHAR(20),owner VARCHAR(20),species VARCHAR(20),sex CHAR(1),birth DATE , death DATE); 查看创建的表 DESCRIBE pet; 插入数据 insert into test VALUES(‘tom’,’panda’,’hamster’,’f’,’2017-02-06’，NULL); 从表中检索数据 select * from pet;","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://anranz.com/tags/MySQL/"}]},{"title":"Builder模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-Builder模式/","text":"Builder模式定义:将复杂的创建与他的表示分离,使同样的创建过程可以创建不同的表示 设计的步骤:Builder builder = new AppleBuilder(); Director director = new Director(builder); director.construct(4,2,&quot;linux&quot;); Log.d(TAG,&quot;test result &gt;&gt;&gt;&gt;&gt; :: &quot; +builder.create().toString()); 以组装电脑为例,创建电脑的抽象类,包含os ram,core定义,提供设置的抽象方法 创建要组装的具体电脑类AppleComputer,继承Computer类,实现所用方法 创建抽象的Builder类,提供builder的设置方法,另外提供返回Computer的create的抽象方法 创建具体的AppleBuilder类实现抽象方法,创建AppleComputer 实例对象,并设置数据,返回AppleComputer的实例 创建具体的Director类,构造方法中接受builder对象,提供接受数据的construct 方法,将参数传递给builder对象 传递的参数最终被AppleBuilder接收,并返回一个具体的AppleComputer对象 具体代码package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public abstract class Computer { protected int mCore = 1; protected int mRam = 10; protected String mOs = &quot;dos&quot;; protected Computer() { } public abstract void setCore(int core); public abstract void setRem(int rem); public abstract void setOs(String os); @Override public String toString() { return &quot;Computer{&quot; + &quot;mCore=&quot; + mCore + &quot;, mRam=&quot; + mRam + &quot;, mOs=&apos;&quot; + mOs + &apos;\\&apos;&apos; + &apos;}&apos;; } } package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public class AppleComputer extends Computer { protected AppleComputer() { } @Override public void setCore(int core) { this.mCore = core; } @Override public void setRem(int ram) { this.mRam = ram; } @Override public void setOs(String os) { this.mOs = os; } } package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public class AppleBuilder extends Builder { private Computer mApplePc =new AppleComputer(); @Override public void buildCore(int core) { mApplePc.setCore(core); } @Override public void buildRam(int ram) { mApplePc.setRem(ram); } @Override public void buildOs(String os) { mApplePc.setOs(os); } @Override public Computer create() { return mApplePc; } } package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public abstract class Builder { public abstract void buildCore(int core); public abstract void buildRam(int ram); public abstract void buildOs(String os); public abstract Computer create(); } package com.anakin.design_pattern_test.demo.singel_instance.builder; /** * Created by demo on 2017/2/8 0008 */ public class Director { Builder mBuilder=null; public Director(Builder builder) { mBuilder = builder; } public void construct(int core,int ram, String os){ mBuilder.buildCore(core); mBuilder.buildRam(ram); mBuilder.buildOs(os); } } 测试代码 // 测试运行效果 Builder builder = new AppleBuilder(); Director director = new Director(builder); director.construct(4,2,&quot;linux&quot;); Log.d(TAG,&quot;test result &gt;&gt;&gt;&gt;&gt; :: &quot; +builder.create().toString());","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://anranz.com/tags/设计模式/"}]},{"title":"代理模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-代理模式/","text":"代理模式定义代理模式是对象结构模式,代理模式给某个对象提供一个代理对象,并由代理对象控制控制原对象的引用. 使用场景简单实现定义抽象类 package com.anakin.design_pattern_test.proxy_method; /** * Created by demo on 2017/2/8 0008 */ public abstract class AbstractObject { // 需要的操作 public abstract void operation(); } 定义真正的实现的类 package com.anakin.design_pattern_test.proxy_method; /** * Created by demo on 2017/2/8 0008 */ public class RealObject extends AbstractObject { @Override public void operation() { System.out.println(&quot; need to do something &gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); } } 定义代理类 package com.anakin.design_pattern_test.proxy_method; /** * Created by demo on 2017/2/8 0008 */ public class ProxyObject extends AbstractObject { @Override public void operation() { // 调用具体操作前可以做操作 AbstractObject real = new RealObject(); real.operation(); // 调用具体操作后可以做操作 } } 测试 // 代理模式测试 AbstractObject proxy =new ProxyObject(); proxy.operation(); 测试结果 02-08 09:46:41.821 18278-18278/com.anakin.design_pattern_test I/System.out: need to do something &gt;&gt;&gt;&gt;&gt;&gt;&gt;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://anranz.com/tags/设计模式/"}]},{"title":"工厂方法模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-工厂方法模式/","text":"工厂方法模式 和简单工厂模式不同是,简单工厂模式,实例都由一个工厂类创建,工厂类的代码量会比较多,而且增加新的对象需要修改工厂类的代码,增加if else 的判断. 工厂模式,创建产品的抽象类和实现类,以及工厂的抽象类和实现类. 以打印log为例,log的存储方式可以是db也可以是file中,需要创建Logger的抽象类,具体是FileLogger实现类和DbLogger的实现类,工厂的抽象类LoggerFactory,和具体的实现类DbLoggerFactory,FileLoggerFactory 在抽象Logger类中定义公共的抽象方法writeLog() 在具体实现类DbLogger和FileLogger中实现各自的具体的writeLog方法 在抽象的工厂类中定义抽象的创建对象的方法creatLogger() 在具体的实类DbLoggerFactory,FileLoggerFactory中实现方法,创建DbLogger和FileLogger的实例,并返回其父类Logger 客户端的使用 : 根据需要创建工厂的实例,调用实例中创建对象的方法creatLogger返回具体log存放的实例对象,在调用具体打印log的方法writeLog()","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://anranz.com/tags/设计模式/"}]},{"title":"单例设计模式.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/设计模式-单例模式/","text":"单例设计模式定义:确保某一类只有一个实例，而且自行实例化并向整个系统提供这个实例 使用场景:确保某个类只存在一个对象,当创建这个对象需要消耗过多的资源时,例如IO 的读取数据库等操作 /** * 第二种方法 */ private static CEO mInstance = null; private CEO() { } public static CEO getInstance() { if (mInstance == null) { synchronized (CEO.class){ if (mInstance == null) { mInstance = new CEO(); } } } return mInstance; }","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://anranz.com/tags/设计模式/"}]},{"title":"Android基础知识.md","date":"2017-02-17T03:25:59.000Z","path":"2017/02/17/Android基础知识-md/","text":"Android学习笔记 五种布局LinearLayout(线性布局) 一行或者一列值放置一个控件的布局,可以设置方向,垂直排列或者水平排列,适用于简单的布局 适用场景:水平或者垂直的简单排列,如登录界面 RelativeLayout(相对布局) 是一个相对自由的布局, 由一个view作为参照,来定位下一个view的摆放位置,可以实现比较复杂的布局 应用场景:适合比较复杂的布局,LinearLayouy能实现的它也能实现 FrameLayout(框架布局) 所有的子view都会放在左上角,无法指定位置,后面的子view会放在前一个view上. 使用场景: 放置单一的view,如放置Fragment,显示一张图片 TableLayout(表格布局) 类似HTML中的table,使用tableRow来布局,tableRow代表一行,其中的每个视图组件代表一个单元格 使用场景:空间之间存在相应关系 AbsoluteLayout (绝对布局) 采用坐标轴的方式来定位view,左上角坐标为(0,0),x轴向右递增,y轴向下递增 使用场景:准确定位控件位置,但是Android设备的屏幕尺寸,分辨率差别很大,无法解决适配问题,该布局已经过时 Activity- Activity的生命周期 正常的生命周期:onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory 转到其他Activity或者按下home键 执行onPause() -&gt; onStop 进入停滞状态 Activity返回前台:onRestart() -&gt; onStart() -&gt; onResume() 当系统内存不足会将后台的Activity杀死,此时这个Activity任然在任务栈中只是引用指向的对象已经为空,若再次回到这个Activity会重新走一遍生命周期 锁屏: onPause -&gt; onStop 解锁: onStart -&gt; onResume Activty任务栈 任务栈是一种先进后出的结构,每个app默认只有一个任务栈以包名命名,位于栈顶的Activity处于焦点状态,当按下back键时,栈内的Activity会一个一个出栈,调用onDestory()方法,如果栈内没有Activity,系统就会回收这个栈. 启动模式: standard :默认的启动模式,每次创建一个新的Activity实例,将其压入任务栈栈顶,不管栈内是否存在这个Activity.Activity启动三次就会调用三次Activity的生命周期. singleTop:栈顶复用模式,启动一个Activity,如果栈顶存在这个Activity的实例,就不在创建新的Activity实例,启动多次也不会创建新的实例,会调用Activity的newIntance()方法,如果栈内存在这个Activity的实例,但不是在栈顶,作用与standard模式一样 singleTask:栈内复用模式,创建Activity的时候,系统会确认它需要的任务栈是否已经创建,否则再创建任务栈,然后放入Activity,如果栈内有一个Activity实例,那么这个Activity会被调到栈顶,调用newInstance()方法,并且会清理这个实例上面的所有Activity singleInstance:加强版的singleTask模式,这种模式Activity实例会单独存在一个任务栈中,由于栈内复用的特性,以后不会再创建新的实例,除非任务栈被销毁 Activity的堆栈管理是以ActivityRecord为单位的,所有的ActivityRecord都放在一个list中,可以认为一个ActivityRecord就是一个Activity栈 Activity的缓存 有两个Activity A,B ,从A进入B,一段时间后,系统可能叫A回收,这时在按back键回到A,会重新走A的生命周期方法onCreate -&gt; onStart -&gt; onResume ,A被重新创建了一次,这时A中保存的数据和状态就会丢失 为了恢复状态,使用onSaveInstanceState()方法保存临时数据和状态,此方法会在Activity销毁前调用,方法中有Bundle参数保存,putString(),putInt()等方法,方法中传入一个参数好一个值,数据保存后会在onCreate()中恢复 onSaveInstanceState调用时机:即系统未经你允许销毁了你的Activity,这是系统的责任，因为它必须要提供一个机会让你保存你的数据 onSaveInstanceState() 会在onStop()前执行,但不保证是在onPause之前还是之后触发 代码 private static final String TAG = &quot;MainActivity&quot;; private static final String SAVE_KEY =&quot;save_key&quot; ; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(savedInstanceState!=null){ // 恢复保存的内容 String save = savedInstanceState.getString(SAVE_KEY); Log.d(TAG,&quot;=== 恢复保存的内容 ==&quot;+save); } initEvent(); } /** * 保存Activity的状态 * @param outState * @param outPersistentState */ @Override public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) { super.onSaveInstanceState(outState, outPersistentState); outState.putString(SAVE_KEY,&quot;保存字符串&quot;); } Intent Intent可以传递的数据类型:可以传递基本数据类型好基本数据类型的数组,以及实现需序列化接口的飞基本数据类型 FragmentFragment的生命周期和Activity的关系onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onViewCreatd() -&gt; Activity onCreated() ….. Fragment的生命周期 Broadcast Receiver的两种动态注册和静态注册有什么区别 动态注册: 在代码中注册,app退出就不能接收到广播 静态注册: 在清单文件中注册,app退出依旧可以接受到广播 ContentProvider使用方法Service为什么在Service中创建子线程 在Activity中创建一个子线程,但Activity被销毁后,就不能获取子线程的实例,而且在在其他Activity中无法对其操作 在Service创建中就不同,所有的Activity都可以对其进行操作,即使Activity 被销毁后,重新与Service进行关联,就可以获取Binder的实例.因此使用Service做后台处理,Activity可以放心的finish ,不用担心对后台任务无法控制的情况 Service的两种启动方法,有什么区别 Context bindService 启动Service 生命周期好Context 绑定在一起 Context startService 启动Service 生命周期和context 无关 如何保证Service不被杀死动画有哪几类,各有什么特点,有什么区别Android的数据存储形式Sqlite的基本操作如何判断应用被强杀Json有什么优劣势Asset目录与res目录的区别优化Android怎么加速启动ActivityAndroid内存优化方法自定义View的流程Android长连接,怎样处理心跳机制View的绘制流程下拉刷新的实现原理常用框架和源码分析，底层原理Android新特性5.06.07.0ContextIntenService使用场景图片缓存查看程序可用最高内存Gradle构建工具","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"MySQL使用.md","date":"2017-01-20T02:22:04.000Z","path":"2017/01/20/MySQL使用/","text":"##ubuntu下使用MySQL## ###安装MySQL### 安装核心服务 sudo apt-get install mysql-server 安装客户端 sudo apt-get install mysql-client ###创蚩菘獾幕静僮?## 打开MySQL :sudo service mysql start 使用root:mysql -u root -p 查看数据库 :show databases; 连接数据库:use&lt;数据库名&gt; 查看表:show tables; 退出:quit 或者exit ###创建数据库和表### 创建数据库: CREATE DATABASES &lt;数据库名? 创建表 : CAEATE TABLE &lt;表名&gt;(?…); ###查询表### 查询全部select * from 表名 条件查询: select 要查询的列名 from where 限制条件 ###条件查询### where后面限制条件可以有数学符号= ,&lt;,&gt;,&gt;=,&lt;= and or : select * from employee where age30; in 和not in:表示在或者不在某个范围内的结果,select name,age,in_dpt FROM employee WHERE in_dpt IN(‘dpt3,dpt4’); LIKE 通配符 ‘‘ 匹配任意字符一个’‘匹配一个字符,’%’匹配不定个字符eg: select name,age FROM employee WHERE phone LIKE ‘11%’###对结果排序### 为了对结果排序,使用ORDER BY排序关键词,默认是升序,使用ASC的DESC可以指定升序或者降序,比如按salary降序排列 降序排列:SELECT name,age,salary,phone FROM employee ORDER BY salary DESC; ###SQL内置函数和计算### COUNT SUM AVG MAX MIN 分别为计数 求和 求平均 最大值 最小值 使用AS关键字给值重命名eg : select max(salary),min(salary) from employee; select count(sum) as salary_count from emplary; ###子查询### 处理多个表才能获取信息,如获取name =’Tom’所在的in_dpt,做了几个projecteg: select count(proj_name) from project where of_dpt in(select in_dpt from employee where name =’Tom’) ###插入语句### insert into 表名(键名) values(值) insert into 表名 values(值) ##约束##常见的约束 主键 PRIMARY KEY 默认值 DEFAULT 唯一UNIQUE 外键FOREIGN KEY 非空 NOT NULL###建立含约束的表###","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://anranz.com/tags/MySQL/"}]},{"title":"Android-读取XML中的配置参数工具类XMLUtil","date":"2017-01-20T02:22:04.000Z","path":"2017/01/20/读取XML中的配置参数/","text":"一个读取xml文件中配置文件的工具类XMLUtil代码如下：import javax.xml.parsers.*; import org.w3c.dom.*; import org.xml.sax.SAXException; import java.io.*; public class XMLUtil { //该方法用于从XML配置文件中提取配置文件 public static String getChartType() { try { //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(&quot;config.xml&quot;)); //获取包含配置文件的文本节点 NodeList nl = doc.getElementsByTagName(&quot;chartType&quot;); Node classNode = nl.item(0).getFirstChild(); String chartType = classNode.getNodeValue().trim(); return chartType; } catch(Exception e) { e.printStackTrace(); return null; } } } XML 文件代码&lt;?xml version=&quot;1.0&quot;?&gt; &lt;config&gt; &lt;chartType&gt;histogram&lt;/chartType&gt; &lt;/config&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://anranz.com/tags/Android/"}]},{"title":"自学Python-常用内建模块","date":"2017-01-14T04:03:14.000Z","path":"2017/01/14/自学Python-常用内建模块/","text":"Python内建模块关于时间# 1. 获取当前时间 from datetime import datetime,timedelta r =datetime.now() print (r) # 2. 获取指定的时间和日期 r1 = datetime(2017,1,14,12,53) print (r1) # 3. 将datetime转换为datestamp t= 12345645.12 r2 = datetime.fromtimestamp(t) print(r2) # 4. str转换为datetime r3 = datetime.strptime(&apos;2017-01-14 15:58:29&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;) print(r3) # 5. datetime转换为str s1 = datetime.now() r4 = s1.strftime(&apos;%a, %b %d %H:%M&apos;) print(r4) # 6. 时间的加减 n1 = datetime.now() print(n1) n2 =n1+timedelta(hours=10) # 增加10小时 print (n2) collections collections是Python的内建模块提供集合操作的类 # Python的内建模块 - collections # 1. 使用namedtuple表示一个点的坐标 from collections import namedtuple,deque,defaultdict,OrderedDict Point = namedtuple(&apos;point&apos;,[&apos;x&apos;,&apos;y&apos;]) p =Point(1,2) print(p.x) print(p.y) # 2. deque 高效的对list进行删除和插入 d = deque([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) s = d.appendleft(&apos;x&apos;) d.append(&apos;z&apos;) d.pop() print(s) print(d) # 3 .defaultdict ,使用dict的时候如果应用的key不存在会抛出keyError ,使用defaultdict 返回一个默认值 dd = defaultdict(lambda :&apos;N/A&apos;) dd[&apos;key1&apos;] =&apos;anakin&apos; s1 = dd[&apos;key1&apos;] s2 = dd[&apos;key2&apos;] print(s1) print(s2) # 4. 使用OrderedDict ,dict 是无序的,迭代的时候不能按照顺序取出数据,使用OrderedDict d1 = dict([(&apos;a&apos;,&apos;1&apos;),(&apos;b&apos;,&apos;2&apos;),(&apos;c&apos;,&apos;3&apos;)]) print(d1) d2= OrderedDict([(&apos;a&apos;,&apos;1&apos;),(&apos;b&apos;,&apos;2&apos;),(&apos;c&apos;,&apos;3&apos;)]) print (d2) # 注意 OrderedDict会按照插入的顺序排序,而不是按照key 的顺序 d3 = OrderedDict() d3[&apos;x&apos;]=3 d3[&apos;z&apos;]=6 d3[&apos;d&apos;]=4 print d3 计数函数Counter 统计字符出现的次数 # Counter 计数的方法,可以统计字符出现的次数 c = Counter() for ch in &apos;luoyang&apos;: c[ch]= c[ch]+1 print (c)","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-正则表达式","date":"2017-01-14T02:46:38.000Z","path":"2017/01/14/自学Python-正则表达式/","text":"正则表达式 [0-9a-zA-Z_]匹配任意数字字母和下划线 [0-9a-zA-Z_]+ 匹配至少一个字母数字下划线组成的字符串 [a-zA-Z_][0-9a-zA-Z_]* 匹配以字母或者下划线开头，后面跟任意个字母或数字 [a-zA-Z_][0-9a-zA-Z_]{0，19} 匹配一字母或者下划线开头，后面0到19个数字或者字母下划线 A|B 可以匹配 A或者B ，（P\\p)ython可以匹配python,或者Python ^ 表示行的开头 ^\\d表示以数字开头 $ 表示行的末尾 re模块 判断表达式是否匹配成功,如果成功,返回一个Match对象,失败返回None # 判断一个电话号码 s= re.match(r&apos;^\\d{3}-\\d{3,8}$&apos;,&apos;012-1234&apos;) print (s) 切割字符串 # 通过空格切割字符串 str = &apos;q we r t&apos; r =re.split(r&apos;[\\s]+&apos;,str); print (r) 分组 除了简单的匹配,正则表达式还可以提取子串,用()表示要提取的分组(Group) # 提取分组 # 提取区号和电话号码 s = re.match(r&apos;^(\\d{3})-(\\d{3,8})$&apos;,&apos;021-5386112&apos;) print (s) g1 =s.group(1) g2 =s.group(2) print (g1) print (g2) 预编译 如果执行横多次的正则匹配,每次执行都要对正则表达式进行编译,出于效率我们可以预编译正则表达式 # 编译 re_tel = re.compile(r&apos;^(\\d{3})-(\\d{3,8})$&apos;) # 使用 s = re_tel.match(&apos;021-5386112&apos;).group() print (s)","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-线程和进程","date":"2017-01-13T07:05:52.000Z","path":"2017/01/13/自学Python-线程和进程/","text":"multiprocessingwindows 创建多线程使用 multiprocessinglinux unix 使用fork() 创建子线程的时候,只需要传入一个函数,和一个参数,创建一个Process实例,用start()方法启动,这样创建进程比fork()简单 from multiprocessing import Process import os # 子进程要执行的代码 def run_proc(name): print(os.getpid()) print(name) print(__name__) if __name__ == &apos;__main__&apos;: print(&apos;prent process %s&apos;%os.getpid() ) # 创建一个子线程 p = Process(target = run_proc,args = (&apos;test&apos;,)) print(&apos; child process will start &apos;) # 开始子线程 p.start() # 放如线程队列 p.join() print(&apos; child process end &apos;) Pool如果要开启大量子线程,可以用线程池批量化创建子线程 from multiprocessing import Pool import os,time,random def long_time_task(name): print(&apos; 开启新的任务...&apos;+name) start = time.time() time.sleep(random.random() * 3) end = time.time() s = end - start print(s) print(name) if __name__==&apos;__main__&apos;: p = Pool(4) for i in range(5): print(&apos;------------&gt;&gt;&gt;&gt; &apos;) p.apply_async(long_time_task, args=(i,)) print(&apos; wait for process done...&apos;) p.close() p.join() print(&apos;all progress done ..&apos;) 子进程 启动一个子进程 import subprocess print(&apos;$ nslookup www.python.org&apos;) r = subprocess.call([&apos;nslookup&apos;,&apos;www.python.org&apos;]) print(&apos;exit code &apos;, r) 进程间通信 进程间传递数据 from multiprocessing import Process,Queue import os,time,random # 写数据进程间执行代码 def write_data(q): print(&apos; pid :%s&apos; %os.getpid()) for value in [&apos;q&apos;,&apos;w&apos;,&apos;e&apos;,&apos;r&apos;]: print(value) q.put(value) time.sleep(random.random()) # 读数据进程间执行代码 def read_data(q): print(&apos; read pid : %s&apos; %os.getpid()) while True: value =q.get(True) print(&apos; 读取的数据 : &apos;+ value) if __name__ == &apos;__main__&apos;: # 父进程创建Quenu,并传递给子进程 q = Queue() pw = Process(target = write_data,args = (q,)) pr = Process(target = read_data,args =(q,)) pw.start() pr.start() pw.join() # pr 是死循环 无法等待其结束,只能强行终止 pr.terminate() 多线程 启动一个线程就是把一个函数传入并创建Thread实例,然后调用start()开始执行 # 创建一个线程,并执行 import time,threading # 新线程的代码 def loop(): print(&apos;线程%s is running ....&apos;%threading.current_thread().name) n =0 while n&lt;5: n=n+1 print(&apos;thread %s &gt;&gt;&gt; %s&apos;%(threading.current_thread().name,n)) time.sleep(1) print(&apos;线程%s is running ....&apos;%threading.current_thread().name) t =threading.Thread(target= loop,name= &apos;LoopThread&apos;) t.start() t.join() Lock 任何一个线程启动一个子线程,我们把该线程称为主线程 当多个线程共享一个变量并操作,导致内容错乱 使用lock.acquire(),当多个线程同时执行lock.acquire(),只有一个线程能成功获取锁,然后继续执行代码,其他线程就继续等待直到获得锁为止,获得锁的线程用完后一定要释放锁,否则会出现其他线程一直等待,成为死线程,所有使用try … finally 确保锁一定会被释放 ThreadLocal ThreadLocal 变量虽然是全局变量，但是每个线程都能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个参数之间互相传递的问题 import threading # 获取全局的ThreadLocal对象 local_school = threading.local() def process_student(): # 获取线程相关的student std = local_school.student print(&apos;hello ,%s(in %s)&apos;%(std,threading.current_thread().name)) def process_thread(name): # 绑定ThreadLocal的student local_school.student= name process_student() # 开启两个线程 t1 =threading.Thread(target= process_thread,args = (&apos;anakin&apos;,),name=&apos;Thread -a&apos;) t2 =threading.Thread(target= process_thread,args = (&apos;hahha&apos;,),name =&apos;Thread -b &apos;) t1.start() t2.start() t1.join() t2.join()","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-IO编程","date":"2017-01-13T01:30:18.000Z","path":"2017/01/13/自学Python-IO编程/","text":"读文件 使用open(‘文件地址’，’标识符’)函数 使用read()读取 最后一步使用close(关闭) 使用with读取，自动关闭 # 使用with 读取，自动关闭 with open(&apos;D:/pro/python/test.txt&apos;,&apos;r&apos;) as f: print(f.read()) 调用readline() 可以一次读取一行内容 调用readlines() 一次读取所有的内容，并返回一个list 不能确定文件大小使用readlines() with open(&apos;D:/pro/python/test.txt&apos;,&apos;r&apos;) as f: for line in f.readlines(): print(line.strip()) 读取二进制文件 打开模式使用’rb’ # 读取二进制文件 with open(&apos;D:/pro/python/img.png&apos;,&apos;rb&apos;) as f: for line in f.readlines(): print(line.strip()) 字符编码 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数 f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;) 遇到非法编码文件，open函数还接受一个errors参数，表示遇到编码错误后如何处理，最简单的方式就直接忽略 f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;,errors = &apos;ignore&apos;) 写文件 与读文件的区别open() 函数的的标识符，传入’w’,’wb’表示写文件和二进制文件 写文件 with open(&apos;D:/pro/python/write.txt&apos;,&apos;w&apos;) as f: f.write(&apos;hello write new file... &apos;) StringIO 和BytesIOStringIO很多时候，数据读写不一定是文件，也可以在内存中读写 在内存中写str，使用getvalue()获取写入的内容 from io import StringIO f = StringIO() f.write(&apos;hello&apos;) f.write(&apos;hello&apos;) f.write(&apos;hello&apos;) print(f.getvalue()) 读取StringIO while True: s =f.readline() if s ==&apos;&apos;: print(&apos;s ==&apos;+ s) break print(s.strip()) BytesIO 内存中读写二进制文件 # 写入二进制文件 from io import BytesIO f = BytesIO() f.write(&apos;你好&apos;.encode(&apos;utf-8&apos;)) s= f.getvalue() print(s) 读取二进制文件 # 读取二进制文件 from io import BytesIO f = BytesIO(b&apos;\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd&apos;) s= f.read() print(s) 操作文件和目录 查看当前目录的绝对路径 import os v= os.path.abspath(&apos;&apos;) # 查看当前目录的绝对路径 print(v) 在某个路径下创建一个新目录,首页把新路径目录表示出来 # 删除一个文件夹 os.rmdir(&apos;D:/pro/python/testdir&apos;) # 对文章重命名 a = os.rename(&apos;test.txt&apos;,&apos;test.py&apos;) #删除文件 d = os.remove(&apos;test.py&apos;) 过滤文件 # 过滤文件,比如列出当前目录下的所有文件夹 s = [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)] print(s) # 过滤文件 ,获得所有的.py文件 s = [ x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;] print(s) 序列化 我们把变量从内存中变成可存储的过程称为序列化序列化后的内容可以写到磁盘上或者通过网络传输 将对象序列化 import pickle d = dict(name=&apos;zhanghua&apos;,age=18,score=100) s =pickle.dumps(d) print(s) 将对象写入文件中 import pickle d = dict(name=&apos;zhanghua&apos;,age=18,score=100) s =pickle.dumps(d) print(s) f= open(&apos;dump.txt&apos;,&apos;wb&apos;) pickle.dump(d,f) f.close() 读取存储在文件中的对象 # 读取存储的对象 r= open(&apos;dump.txt&apos;,&apos;rb&apos;) o = pickle.load(r) r.close() print(o) JSON我们要在不同的编程语言中传递对象,就必须把对象序列化为标准格式,如xml 和json 序列化json和反序列化json import json # 序列化 d = dict(name=&apos;Bob&apos;,age=20,score=88) j = json.dumps(d) print(j) # 反序列化 json_str = &apos;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&apos; s =json.loads(json_str) print(s) 将实例对象序列化 class Student(object): def __init__(self, name,age,score): self.name = name self.age = age self.score = score s = Student(&apos;anakin&apos;,18,100) # 将实例转换为json j = json.dumps(s,default=lambda obj : obj.__dict__) print(j) json反序列化成对象 # json 反序列化成对象 def dict2student(d): return Student(d[&apos;name&apos;],d[&apos;age&apos;],d[&apos;score&apos;]) json_str = &apos;{&quot;score&quot;: 100, &quot;name&quot;: &quot;anakin&quot;, &quot;age&quot;: 18}&apos; r = json.loads(json_str, object_hook=dict2student) print(r)","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-面向对象高级编程","date":"2017-01-12T06:30:26.000Z","path":"2017/01/12/自学Python-面向对象高级编程/","text":"使用slots 正常情况下定义一个class,创建class实例后,我们可以给实例绑定任何属性和方法,这就是动态语言的灵活性 绑定属性 class Student(object): def __init__(self, name): super(Student, self).__init__() self.name = name s = Student(&apos;anakin&apos;) s.age = 10 print(s.age) # 给对象绑定属性 print(s) 绑定方法 这样给实例绑定一个方法,对另外一个实例是不起作用的 class Student(object): def __init__(self, name): super(Student, self).__init__() self.name = name # 给实例绑定一个方法 s = Student(&apos;anakin&apos;) def set_age(self,age): self.age= age from types import MethodType s.set_age= MethodType(set_age,s) s.set_age(25) print(s.age) # 25 为了给所有实例绑定方法,可以给class绑定方法 def set_score(self,score): self.score=score Student.set_score =set_score # 给类绑定方法 s.set_score(&apos;abc&apos;) print(s.score) 使用slots 限制绑定的属性 class Student(object): __slots__ = (&apos;name&apos;,&apos;age&apos;) # 限制绑定的属性 s = Student() s.name= &apos;anakin&apos; print(s.name) # s.score =&apos;abc&apos; # 绑定score会报错,因为限制了绑定的属性 # print(s.score) 注意: slots 只对当前的类起作用,对子类没有作用 使用@property 通过提供set和get方法,检查参数 class Student(object): # 提供getScore和setScore方法 def get_Score(self): return self._score def set_Score(self,value): if not isinstance(value,int): print(&apos;输入数据类型错误&apos;) if value&lt; 0 or value &gt; 100: print(&apos;数据超出范围&apos;) self._score= value s = Student() s.set_Score(105) 使用@property 对设置的属性进行检查s.score=109 相当于s.set_score(109)``,s.score 相当于s.get_score() class Student(object): @property def score(self): return self._score @score.setter def score(self,value): if not isinstance (value,int): print(&apos;数据类型不合法&apos;) if value &lt; 0 or value &gt; 100: print(&apos;数据超出范围&apos;) self._score =value s= Student() s.score=109 print(s.score) 定义只读属性，提供get方法，不提供set方法 class People(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth p = People() p.birth=1993 print(p.birth) print(p.age) 多重继承 Python支持多继承 定制类 Python 中有很多特殊用途的函数，帮助我们定制类 __str__() 作用：返回自定义的字符串 # 定制函数 class Student(object): &quot;&quot;&quot;docstring forStudent.&quot;&quot;&quot; def __init__(self, name): self._name = name def __str__(self): return &apos;Student name :&apos;+self._name s =Student(&apos;anakin&apos;) print(s) 让用户看到的字符串和程序开发者看到的字符串是一样的使用__repr__ # 定制函数 class Student(object): def __init__(self, name): self._name = name def __str__(self): return &apos;Student name :&apos;+self._name __repr__ =__str__ s =Student(&apos;anakin&apos;) print(s) __iter__ 如果一个对象想被for..in ...循环 ，就要实现__iter__函数 ，返回self class Fib(object): def __init__(self): self.a,self.b = 0,1 def __iter__(self): return self def __next__(self): self.a ,self.b = self.b,self.a+self.b if self.a&gt;10000: raise StopIteration(); return self.a for x in Fib(): print(x) __getitem__ 实现__iter__ 方法可以使类for.. in..循环，实现getitem可以通过角标获取元素 class Fib(object): def __init__(self): self.a,self.b = 0,1 def __iter__(self): return self def __next__(self): self.a ,self.b = self.b,self.a+self.b if self.a&gt;10000: raise StopIteration(); return self.a def __getitem__(self,n): a,b =1,1 for x in range(n): a,b =b,a+b return a for x in Fib(): print(x) f= Fib() print(f[20]) __getattr__ 那就是写一个getattr()方法，动态返回一个属性 class Student(object): def __init__(self): self.name =&quot;anakin&quot; def __getattr__(self,attr): if attr == &apos;age&apos;: return 18 s= Student() print(s.name) print(s.age) __getattr__()方法 也可以返回一个方法，调用方式对象.方法（） __call__ 调用类中的方法 class Student(object): &quot;&quot;&quot;docstring forStudent.&quot;&quot;&quot; def __init__(self): self.name =&apos;anakin&apos; def __call__(self): print(&apos;调用自己的方法。。。。&apos;) s= Student() s()","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-面向对象编程","date":"2017-01-11T11:38:56.000Z","path":"2017/01/11/自学Python-面向对象编程/","text":"类class Student(object): def __init__(self, name,score): self.name = name self.score = score def print_score(self): print(&apos;%s: %s&apos; % (self.name,self.score)) s1 = Student(&apos;anakin&apos;,18) s2 = Student(&apos;anran&apos;,18) s1.print_score() s2.print_score() 定义类以class开头,后买年跟类名,类名后面的括号中写继承的类(一般默认继承Object) 和普通函数相比,在类中定义函数,第一个变量永远是实例变量self,但是调用的时候不用传入,Python解释器会自动把实例变量传进去 数据封装 我们直接擦操作了对象内部数据,但无法知道方法内部的实现细节 访问限制 在Class内部,有属性和方法,而外部代码通过直接调用实例变量的方法来操作数据,这样就隐藏了内部的复杂逻辑 如果要想是内部属性不被外部访问,在属性名称前面加,在Python中如果变量名以开头,就变成了私有变量,只有内部可以访问,外部不能访问 不能被直接访问 class Student(object): def __init__(self, name,score): self.__name = name self.__score = score def print_score(self): print(&apos;%s: %s&apos; % (self.__name,self.__score)) s1 = Student(&apos;anakin&apos;,18) print(s1.__name); 外部如果想访问和修改实例的,可以通过get和set方法 class Student(object): def __init__(self, name,score): self.__name = name self.__score = score def print_score(self): print(&apos;%s: %s&apos; % (self.__name,self.__score)) def get_name(self): return self.__name def set_name(self,name): self.__name=name s1 = Student(&apos;anakin&apos;,18) print(s1.get_name()) s1.set_name(&apos;change&apos;) print(s1.get_name()); print(s1.print_score()) 注意 : 类似xxx_ ,双下划线开头,双下划线结尾属于特殊变量,特殊变量可以直接访问,所以在命名变量名的时候不要使用xxx 这样的变量名 类似_name的实例变量,外部是可以访问的,但是按照约定俗成的固定,这样的实例看作是私有的 继承 继承的好处,子类可以获得父类的全部功能 子类和父类存在同样的方法,这时我们说子类覆盖了父类的方法,运行时会调用子类的方法,这样我们就获得了继承的另外一个好处:多态 class Animal(object): def run(self): print(&apos;aninmal is running....&apos;) class Dog(Animal): def run(self): print(&apos;Dog is running....&apos;) class Cat(Animal): def run(self): print(&apos;Cat is running....&apos;) d = Dog() c = Cat() d.run() c.run() 多态 对于静态语言像java ,如果需要传入Anima类型,则传入的对象必须是Animal类型或者它的子类,否则无法调用run方法 对于动态语言想Python,则不一定要传入Animal类型,只需要保证传入的对象有一个run方法就可以了 动态语言的的”鸭子类型”,比要求严格的继承体系,一个对象只要”看起来像鸭子”,那它就可以被看作是鸭子. 获取对象信息 判断基本数据类型 s= type(&apos;123&apos;) print(s) 判断一个对象是否是函数,使用types提供的函数 import types &apos;判断对象是否是函数&apos; def fn(): pass s= types.FunctionType print(s) &apos;判断对象是否是函数&apos; def fn(): pass s= types.FunctionType s2 =types.BuiltinFunctionType s3 = type(abs)==s2 print(s3) print(s) isinstance()函数 &apos;isinstance()函数&apos; class Animal(object): pass class Dog(Animal): pass class Cat(Animal): pass a =Animal() d =Dog() c = Cat() s = isinstance(d,Animal) print(s) 判断是否是其中一种 s=isinstance([1,2,3],(list,tuple)) print(s) 使用dir() 获得一个对象的所有属性和方法使用dir() 配合使用getattr(),setattr(),hasattr(),可以直接操作一个对象的状态 class Animal(object): def __init__(self): self.x= 9 def power(self): return self.x*self.x a = Animal() s1 =hasattr(a,&apos;x&apos;) s2 =hasattr(a,&apos;y&apos;) s3 =getattr(a,&apos;x&apos;) s4 =setattr(a,&apos;x&apos;,4) s5= getattr(a,&apos;x&apos;) print(s1) print(s2) print(s3) print(s4) print(s5) 实例属性和类属性 Python是动态语言,根据类创建的实例可以绑定任意属性,可以删除 如果类中存在这个属性,绑定新的属性,会得到新绑定的属性,如果删除就得到类的属性,绑定的属性只能通过类的实例调用,不能通过类名获取","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-Python基础.md","date":"2017-01-11T11:38:56.000Z","path":"2017/01/11/自学Python-Python基础/","text":"注释 以#开头作为注释右面的代码不会被执行 代码格式 语法比较简单,不同于java以分号作为结束,Python采用缩进的方式,所以代码格式非常重要 数据类型和变量数据类型 整数:可以处理任意大小的整数 浮点数 : 1.11, -3.15,,对于很大和很小的浮点数需要用科学计数法 注意:证书和浮点数在计算机内部存储方式是不同的,整数永远是精确的(除法也是精确的),浮点可能会四舍五入 字符串:以单引号或者双引号括起来的任意文本,”字符串”,’字符串’ boolean :一个布尔值只有True ,False两种值 注意大小写 空值:一个特殊的值None,不能理解为0 ,0是有意义的,None是一个特殊的空值 变量 变量不仅可以是数字,可说是任意数据类型,变量在程序中使用一个变量名表示,变量名必须符号命名规范 “=” 是赋值语句,表示把任意数据类型赋值给变量,同一个变量可以反复赋值,而且可以是不同类型的变量 eg:a= 123, a=’abc’ 这种变量本身不固定的语言称为动态语言,与之对应的静态语言比如java,定义变量时必须指定变量的数据类型,并且,一旦指定就不能被其他类型的变量赋值 常量 常量是不能改变的变量,比如数学中的常数π,就是一个常量,通常用全部大学表示常量 Python中的除法 / 10/3 = 3.33333333整数相除得到的结果是浮点数 // 10//3 =3 只取结果的整数部分","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-模块","date":"2017-01-11T09:35:35.000Z","path":"2017/01/11/自学Python-模块/","text":"使用模块标准注释 #!/usr/bin/env python3 # -*- coding: utf-8 -*- test_1.py #!/usr/bin/env python3 # -*- coding: utf-8 -*- &apos;a test module&apos; ___author__=&apos;anakin&apos; import sys def test(): args = sys.argv if len(args)==1: print(&apos;hello,world&apos;) elif len(args)==2: print(&apos;hello :&apos;+ args[1]) else: print(&apos;too many argument!&apos;) if __name__==&apos;__main__&apos;: test() test_2.py import test_1 test_1.test() 作用域 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 #!/usr/bin/env python3 # -*- coding: utf-8 -*- &apos;函数的作用域&apos; ___author__=&apos;anakin&apos; def _private_1(name): print(&apos;private 1 run&apos;) def _private_2(name): print(&apos;private 2 run&apos;) def greeting(name): if len(name)&gt;3: return _private_1(name) else : return _private_2(name) 安装第三方模块 安装Pillow 安装Pillow pip install Pillow from PIL import Image im = Image.open(&apos;img.png&apos;) print(im.format,im.size,im.mode) 生成缩略图 im.thumbnail((200, 100)) im.save(&apos;thmb.jpg&apos;,&apos;JPEG&apos;)","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-函数式编程.md","date":"2017-01-11T06:01:12.000Z","path":"2017/01/11/自学Python-函数式编程/","text":"高阶函数 变量可以指向函数，函数的参数能接收变量，那么一个函数可以接收另一个函数作为参数，这种函数就称为高阶函数 变量可以指向函数 函数也是变量 传入函数 def add(x,y,f): return f(x)+f(y) s= add(2,3,abs) print(s) map/reducemap map 接收两个参数，一个函数，一个Iterabale,map将传入的函数依次祖作用到序列的每个元素，并把结果作为新的Iterator返回 def f(x): return x*x L=[1,2,3,4,5] m=map(f,L) s=list(m) print(s) 一个集合中的元素转换成字符串 m=map(str,[1,2,3,45]) s=list(m) print(s) reduce reduce的用法，把一个函数作用在一个序列[x1,x2,x3…],必须接&gt;收两个参数,return结果继续和序列的下一个元素做累积运算 from functools import reduce def fn(x,y): return x*10+y s=reduce(fn,[1,2,3,4]) print(s) filterfilter()函数用于过滤序列 和map()不同的是filter(),接收两个参数,一个函数和一个序列, &gt; 依次将函数作用序列的每一个元素,根据返回值是ture 还是false 决定保留还是丢弃该元素 筛选出奇数 def is_odd(n): return n%2==1 f =filter(is_odd,[1,2,3,4,5,6]) s = list(f) print(s) sorted 对list进行排序 s= sorted([1,2,3,53,21,0,3]) print(s) 可以接收一个key进行自定义排序 s= sorted([1,-2,-3,-53,21,0,3],key=abs) print(s) 根据字母顺序排列 L =[&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;] s =sorted(L,key=str.lower) print(s) 返回函数返回一个函数 def lazy_sum(*arg): def sum(): temp =0 for i in arg: temp = i+ temp return temp return sum f= lazy_sum(1,2,3,4) print(f) s = f() print(s) 总结 函数可以返回一个结果,也可以返回一个函数 返回函数时,函数并未执行,返回函数中不要应用任何可能会变化的变量 匿名函数匿名函数使用Lambda 表达式 L = [1,2,3,4] m = map(lambda x : x*x,L) s = list(m) print(s) 关键字lambda表示匿名函数,冒号前面的x就是参数 限制:只能有一个表达式,不用写retuen ,结果就为返回值 好处:不用担心命名冲突,可以把匿名函数赋值给一个变量,通过变量调用函数 同样,匿名函数也可以作为返回值返回 def build(x,y): return lambda:x*x+y*y f = build(1,2); print(f) 装饰器代码中*arg可变参数,**kw 关键字参数 def log(func): def wrapper(*arg,**kw): print(&apos;call :&apos;+func.__name__) return func(*arg,**kw) return wrapper @log def now(): print(&apos;print log&apos;) now() 偏函数import functools int2 = functools.partial(int,base=2) s =int2(&apos;10000&apos;) print(s) 当函数的参数太多需要简化时,functools.partial()创建一个新的函数,这个函数可以固定原函数的部分参数,是函数调用更简单","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-高级特性","date":"2017-01-11T01:23:15.000Z","path":"2017/01/11/自学Python-高级特性/","text":"切片使用场景： 取一个list或者tuple的部分元素 L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;] r=L[0:3] print(r) [X:Y] X:代表开始的角标，Y:结束的角标，可以是负数，从后向前取 tuple 与list 的区别是tuple是不可变的 tupel也可以切片操作，只是结果仍然是tuple T= (1,2,3,4,5) print(T) r= T[:3] print(r) print(T) 结果： (1, 2, 3, 4, 5) (1, 2, 3) (1, 2, 3, 4, 5) 字符串’xxxx’也可以看成是list,每个元素就是一个字符，字符串也可以切片操作，结果仍然是字符串 T= &apos;abcdefg&apos; print(T) r= T[:3] print(r) print(T) 结果 abcdefg abc abcdefg 迭代通过for in 循环遍历list和tuple ,这种遍历称为迭代 可以对字符串，tuple ,list ,dict进行迭代 迭代dict获取key: d={&apos;1&apos;:&apos;a&apos;,&apos;2&apos;:&apos;b&apos;,&apos;3&apos;:&apos;c&apos;} for x in d: print(x) 迭代dict获取values d={&apos;1&apos;:&apos;a&apos;,&apos;2&apos;:&apos;b&apos;,&apos;3&apos;:&apos;c&apos;} for x in d.values(): print(x) 判断是否可以迭代 from collections import Iterable r =isinstance(&apos;abc&apos;,Iterable) print(r) 迭代list 获取角标-元素对 L = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;] for i,values in enumerate(L): print(i,values) python for 循环可以同时应用两个变量 L = [(1,1),(2,4),(3,9)] for x,y in L: print(x,y) 结果 (1, 1) (2, 4) (3, 9) 列表生成式写列表生成式的时，把要生成的元素x*x放在前面，后面跟for循环，就可以创建list求偶数的平方和 L = [x*x for x in range(1,11) if x%2==0] print (L) 双层循环，生成全排列 L = [m+n for m in &apos;abc&apos; for n in &apos;xyz&apos;] print(L) [&apos;ax&apos;, &apos;ay&apos;, &apos;az&apos;, &apos;bx&apos;, &apos;by&apos;, &apos;bz&apos;, &apos;cx&apos;, &apos;cy&apos;, &apos;cz&apos;] for循环同时可以使用两个或者更多的个变量dict的items()可以同时迭代key和value D = {1:&apos;A&apos;,2:&apos;B&apos;,3:&apos;C&apos;} for x, y in D.items() : print(x,&apos;=&apos;,y) 把集合中的元素都变成小写 L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;] r= [s.lower() for s in L] print(r) 生成器在Python中一边循环一边计算的机制，称为生成器：generator 创建generator 把列表生成器的[]改成（），就可以创建genetator g= (x for x in range(100)) print(g) 获取生成器中的元素，使用迭代的方式 g= (x for x in range(100)) for y in g: print(y) 斐波拉契数列 def fib(max): a,b,n= 0,1,0; while n &lt; max: print(b) a,b=b,a+b n=n+1 return &apos;done&apos; fib(100） 将打印斐波拉契数列改变成genetator 需要将print变成yield 迭代器可以直接作用于for 循环的的数据类型 集合数据类型，如 list,tuple,set,str generator,包括生成器自带的yield 的generator funxtion 使用isinstance()判断对象是否是Iterable from collections import Iterable r =isinstance([],Iterable) print(r) 生成器不但可以作用于for循环，还可以调用next(),获取下一个值可以被next()调用，并不断返回下一个值的对象称为迭代器 总结： 凡是可以用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python- 函数","date":"2017-01-10T08:30:36.000Z","path":"2017/01/10/自学Python-函数/","text":"调用函数Python内置了很多有用的函数，我们可以直接调用。 要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数 调用函数的要传入正确的参数个数和参数类型 数据类型转换 比如int() 把其他类型转换为整数 定义函数定义函数使用 def 后面依次跟 函数名 括号() 冒号: 然后在缩进语句块中写函数体,函数返回值用retun返回 导入函数 定义函数run保存为functions.py ,在test.py 中调用run函数,需要使用from functions import run导入函数run() 空函数定意一个函数什么也不做 def nullFun(): pres 参数检查 调用函数时如果参数的个数不对,会抛出异常 如果参数类型不对,不会被检查出来 检查参数: def my_abs(x): if not isinstance (x,(int,float)): raise TypeError(&apos;bad operand type&apos;) if x&gt;0: return x else : return -x print(my_abs(4)) 返回多个值import math def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny x,y = move(100,100,60,math.pi/6) print(x,y) 实质是返回了一个tuple 函数的参数Python 可以使用默认参数,可变参数,关键字参数 位置参数def power(x): return x*x print(power(2)) 默认参数 必选参数在前面,默认参数在后面 函数有多个函数时,把变化大的放在前面,变化小的放在后面 def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s print(power(6)) # 36 print(power(6,2))# 36 print(power(2,3))# 8 添加一个list 并在最后加上”END”,默认参数初始赋值为None def add_end(L=None): L.append(&apos;END&apos;) return L print(add_end([1,2,3])) 可变参数定义可变参数在参数前面加一个* def calc(*number): sum =0 for n in number: sum = sum+n*n return sum print(calc(1,2,3,4)) print(calc(1,2)) #传入一个集合,在集合前面加上一个* nums =[1,2,3] print(calc(*nums)) 关键字参数 可变参数允许传入0个或者任意个参数,这些可变参数在函数中会自动组装为一个tuple 关键字参数允许你传入0个或者任意个参数名的参数,这些关键字参数在函数内部自动组装为一个dict 当有多个参数时使用dict 进行组合,作为参数 def person(name,age,**kw): print(&apos;name&apos;,name,&apos;age&apos;,age,&apos;other&apos;,kw) extra ={&apos;city&apos;:&apos;beijing&apos;,&apos;job&apos;:&apos;enginner&apos;} person(&apos;ankin&apos;,24) person(&apos;ankin&apos;,24,city=extra[&apos;city&apos;],job=extra[&apos;job&apos;]) 命名关键字参数 关键字参数,函数的调用者可以传入任意不受限制的关键字参数,至于传入哪些,需要再函数的内部通过kw 检查 命名关键字必须传入参数名 def person(name, age, *, city, job): print(name, age, city, job) person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;) 递归函数以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 def fact(n): if n==1: return 1 return n * fact(n - 1)","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"自学Python-Python基础二","date":"2017-01-10T07:06:47.000Z","path":"2017/01/10/自学Python-Python基础二/","text":"使用list和tuplelsit集合 list 是一种有序集合,可以随时添加和删除元素 classmates =[&apos;xxx&apos;,&apos;yyyy&apos;,&apos;zzzz&apos;] print(classmate) 使用索引获取每个位置的元素,索引从0开始 classmates[1] # 结果&apos;l&apos; 当索引超出边界会报IndexError 增加元素 classmates.append(‘Adam’) 插入元素 classmates.insert(1,’ankain’),(插入的位置,插入的元素) 删除末尾的元素 classmats.pop() 删除指定位置元素 classmates.pop(1) ,(删除元素的索引) 替换元素 classmats[1]=’直接给索引赋值’ list 中的元素也可以是list tuple有序列列表叫做元组tuple与list类似,但是tuple一旦初始化就不能被修改,没有增加和删除的等方法,获取元素方式和list一样 初始化:f=() 条件判断age =3 if age &gt;= 18: print(&apos;年轻人&apos;) elif age&gt;=6: print(&apos;小孩子&apos;) else: print(&apos;其他&apos;) input录入用户的输入到年龄 使用birth接收 birth = input(‘borth’) if birth&gt;=18: print(‘chengnianren’) elif birth&gt;=60: print(‘old man’) else: print(‘hahhahhh’) 循环Python有两种循环 for ..in sum =0 for x in range(101): sum+=x print(sum) while n= 101 sum =0 sum=sum+n n=n-2 print(sum) dict和setdict 就像java 中的map使用键值对key - velues 存储,查找速度快set 也是一组key的集合,但是没有value ,而且不能存储重复的元素 dictmap ={&apos;xiaoming&apos;:90,&apos;xiaohong&apos;:100,&apos;laowang&apos;:99} print(map[&apos;xiaoming&apos;]) 一个key只能对应一个value 重复放入同一个key会把前面的value冲掉 如果key不存在,会报错 判断key是否存在一种方法 : &#39;anakin&#39; in map 另外一种方法 : map.get(&quot;key&quot;) 返回None 或者对应的value 删除key key.pop(&#39;key&#39;) 对应的value也会被删除dict和list的区别 查找和插入速度快,不会随着key的增加而变慢 需要占用大量内存 list则相反 set是一个无序,不重复的集合创建set 创建set需要提供一个list : s =set([1,2,3]) 增加元素 通过add(‘add’) 重复添加没有效果 删除元素 通过remove(key) 删除元素 交集和并集运算 s1 = set([1,2,3]) s2 = set([1,2,4]) print(s1&amp;s2) print(s1|s2) 可变对象和不可变对象 str 是不可变对象 list 是可变对象","tags":[{"name":"Python","slug":"Python","permalink":"http://anranz.com/tags/Python/"}]},{"title":"代码示例","date":"2017-01-10T01:57:30.000Z","path":"2017/01/10/代码示例/","text":"package com.dy.dyth.base; import android.graphics.Bitmap; import android.graphics.Canvas; import android.graphics.drawable.Drawable; import android.support.v7.widget.RecyclerView; import android.view.KeyEvent; import android.view.View; import android.view.ViewGroup; import java.util.ArrayList; import java.util.List; /** * 创建者 demo * 创建时间 2016/7/26 16:48 * &lt;p&gt; * 更新者 $Author$ * 更新时间 $Date$ */ public abstract class BaseAdapter&lt;T&gt; extends RecyclerView.Adapter { private static final String TAG = &quot;BaseAdapter&quot;; public List&lt;T&gt; mDatas = new ArrayList&lt;&gt;(); public int layoutResId; public int layoutResIdtwo; //两种布局 public RecyclerView mRecyclerView; public BaseAdapter() { } public BaseAdapter(List&lt;T&gt; data, int layoutResId) { this.mDatas = data; this.layoutResId = layoutResId; } /** * 两种布局 * * @param data * @param layoutResId * @param layoutResIdtwo */ public BaseAdapter(List&lt;T&gt; data, int layoutResId, int layoutResIdtwo) { this.mDatas = data; this.layoutResId = layoutResId; this.layoutResIdtwo = layoutResIdtwo; } //设置回调监听 public interface OnFocusChange { void onFocusChangeListener(View v, boolean hasFocus, int position); } OnFocusChange mOnFocusChange; public void setOnFocusChange(OnFocusChange listener) { this.mOnFocusChange = listener; } //按键监听 public interface OnKey { void onKeyListener(View v, int keyCode, KeyEvent event, Object o, int position); } OnKey mOnKey; public void setOnKeyListener(OnKey listener) { this.mOnKey = listener; } // 长按 public interface OnLongClick { void onLongClickListener(View v, int position, Object bean); } OnLongClick mOnLongClick; public void setOnLongClickListener(OnLongClick listener) { this.mOnLongClick = listener; } //按下监听 public interface OnClick { void onClickListener(View v, int position, Object bean); } OnClick mOnClick; public void setOnClickListener(OnClick listener) { this.mOnClick = listener; } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { return initCreateViewHolder(parent, viewType); } protected abstract RecyclerView.ViewHolder initCreateViewHolder(ViewGroup parent, int viewType); @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, final int position) { final int itemPosition = holder.getLayoutPosition(); initBindViewHolder(holder, itemPosition); final Object bean = mDatas.get(position); //按下监听 if (mOnClick != null) { holder.itemView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mOnClick.onClickListener(v, itemPosition, bean); } }); } // 焦点监听 if (mOnFocusChange != null) { holder.itemView.setOnFocusChangeListener(new View.OnFocusChangeListener() { @Override public void onFocusChange(View v, boolean hasFocus) { mOnFocusChange.onFocusChangeListener(v, hasFocus, itemPosition); } }); } //长按监听 if (mOnLongClick != null) { holder.itemView.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View v) { mOnLongClick.onLongClickListener(v, itemPosition, bean); return true; } }); } //按键监听 if (mOnKey != null) { holder.itemView.setOnKeyListener(new View.OnKeyListener() { @Override public boolean onKey(View v, int keyCode, KeyEvent event) { mOnKey.onKeyListener(v, keyCode, event, bean, position); return false; } }); } } protected abstract void initBindViewHolder(RecyclerView.ViewHolder holder, int position); @Override public int getItemCount() { if (mDatas != null) { return mDatas.size(); } return 0; } /** * 解决当显示两张相同资源图片的时候，发生抖动，提高图片质量为Bitmap.Config.ARGB_8888 * * @param drawable 当前资源 * @return bitmap对象 */ private Bitmap drawableToBitmap(Drawable drawable) // drawable 转换成bitmap { int width = drawable.getIntrinsicWidth();// 取drawable的长宽 int height = drawable.getIntrinsicHeight(); Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);// 建立对应bitmap Canvas canvas = new Canvas(bitmap);// 建立对应bitmap的画布 drawable.setBounds(0, 0, width, height); drawable.draw(canvas);// 把drawable内容画到画布中 return bitmap; } }","tags":[]},{"title":"日常笔记.md","date":"2017-01-09T09:59:29.000Z","path":"2017/01/09/日常笔记/","text":"遇到的问题方法1 .使用mainup 解决左边不显示焦点框 2 .使用boderview 解决recyclerview 滑动中焦点的错位 3 .使用recylcerviewtv 控制焦点在中间 4 .recyclerview 显示左边复杂布局 选择方法 1 ， 3问题 了解框架 焦点框错位1. 焦点框图片 2. 计算方法 3. 布局文件问题 选择方法1. 布局问题 package com.dy.dyth.view; import android.content.Context; import android.support.annotation.Nullable; import android.support.v7.widget.RecyclerView; import android.util.AttributeSet; /** * Created by lph on 2016/8/17. * adapter TV */ public class TvRecyclerView extends RecyclerView { public TvRecyclerView(Context context) { this(context,null); } public TvRecyclerView(Context context, @Nullable AttributeSet attrs) { this(context, attrs,0); } public TvRecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); init(); } private void init(){ setChildrenDrawingOrderEnabled(true); } //设置当前选中条目显示在最前面 @Override protected int getChildDrawingOrder(int childCount, int i) { int currentPos = getChildAdapterPosition(findFocus()); if(i==childCount-1){ return currentPos; } if(i==currentPos){ return childCount - 1; } return super.getChildDrawingOrder(childCount, i); } } 问题首页焦点在滑动过程中错位####解决办法 #### 1. 修改本来布局 在layoutmanger中找到问题 2. 使用新的框架 分析1. 新框架需要改动的东西太多 2. 原有框架不明确出问题的地方 综合考虑1 .半天时间在原有框架上找出解决方法 2 .无法解决，则使用新的框架 ###超出边界分析 1. 为什么滑动的过程中会超出边界 1. recycler View 或者gridLyaoutManger 本身的问题 2. 或者 我自己布局的问题 解决方法 当滑动停止的时候 recyclerView 向右移动 使recyclerview的滑动不超过边界 原因确认 view放大没有超出边界 解决方法 手动当view获取焦点手懂控制recycler 向右移动10dp 头大 2016年9月5日09:51:14 问题 焦点框方法 修改布局 坚持一种方法 不要一直换 使用框架，了解基本用法 记住 clipToPadding就是说控件的绘制区域是否在padding里面的 clipChildren是指子控件是否超过padding区域 ###初始化显示焦点框## 隐藏不了 显示时间天气 wifi显示圆角图片 2016年9月7日10:56:09 待解决 页面切换焦点的问题 分类和首页item 在没有焦点的情况下隐藏焦点框 首页appinfo 按下鼠标下键的焦点切换 2016年9月9日 14:30:46 解决方法 在第三方库中找到焦点框的变化,设置显示影藏 2016年9月12日09:43:33 模拟网络请求显示图片 使用okhttp 使用rxjava 修改坑位命名 homekw_1; http://192.168.1.119:8080/home/home.json http://192.168.1.119:8080/home/kw1.png 解决打开app 应用崩溃的问题 2016年9月13日10:28:43 设置launcher 添加下面属性 &lt;category android:name=&quot;ansroid.intent.category.HOME&quot;/&gt; &lt;category android:name=&quot;ansroid.intent.category.DEFAULT&quot;/&gt;` 问题 ： 打开app后laucnher崩溃原因 ： bean中的Drawable没有序列化####解决办法#### 修改bean中的Bean 重写home中的app管理逻辑 360的实现方法 Bugly 日志:帐号:2014161860密码:dyth123456Bugly崩溃日志 : https://bugly.qq.com/issueIndex?app=900052943&amp;pid=1git命令：提交到远程服务器git remote add origin git@github.com:AnCorleone/TvVertiacalViewPager.git关联一个远程库 git remote rm origin // 添加错误清楚仓储 git push -u origin master //第一次推送master分支的所有内容 git push origin master //推送最新修改 同步代码 合并 解决冲突git fetch origin master:temp git merge temp 查看分支git branch Git忽略规则及.gitignore规则不生效的解决办法Git忽略规则及.gitignore规则不生效的解决办法 :http://www.pfeng.org/archives/840 解决打开app launcher崩溃2016年9月14日16:41:05 将Drawable 从bean 中移除 2016年9月18日13:51:15 monkey 测试adb shell monkey -p com.dy.dyth –-throttle 300 500 // monkey 测试命令 app 管理 卸载app 判断用户是否卸载成功2. 影梭购买地址 ：https://shadowsocks.com/ 服务器搭建 ： https://www.loyalsoldier.me/fuck-the-gfw-with-my-own-shadowsocks-server/ 服务器搭建(大胡子) :http://www.barretlee.com/blog/2016/08/03/shadowsocks/ 搬瓦工 :http://banwagong.cn/ 阿里服务器网址 ：https://account.aliyun.com/alipay/quick_login_return.htm?email=1018966939%40qq.com&amp;is_success=T&amp;notify_id=RqPnCoPT3K9%252Fvwbh3InWesh3oVFcSYEmWEsOrU6Ju2PrpgPSTlRM7rUmqTlV9kW%252F9%252B99&amp;real_name=%E5%BC%A0%E5%AE%89%E7%84%B6&amp;token=20160918d1f108c5face4ef69365c381a89a0X20&amp;user_id=2088602257446202&amp;sign=37548480cde2b1f14e73a5c3dc51220d&amp;sign_type=MD5 影梭指南 :http://www.auooo.com/2015/06/26/shadowsocks%EF%BC%88%E5%BD%B1%E6%A2%AD%EF%BC%89%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/ 2016年9月19日 09:43:17 路线深圳 ——&gt; 南昌（10.1 5：13）——&gt;长沙 ——&gt; 武昌（10.1 9：31） ——&gt; 襄阳——&gt;南漳（签证） 电子地图 ：http://poi.mapbar.com/ 2016年9月20日09:42:44 安装和卸载软件更新界面 监听广播，有软件安装获取安装的软件信息，或者重新查询一遍获取所有的app重新加入集合 notify adapter 卸载软件 获取卸载的软件信息 ，从mall集合中移除或者重新查询，notify()问题 ： 安装软件空指针异常，软件崩溃 安装和卸载软件后焦点跑到home 上了 ，并显示了焦点框 adb pathadb path :C:\\DevTools\\Android\\Sdk\\platform-tools 脚本代码 ：@ECHO off @REM 无限循环的标签 :LOOP ECHO 请插入手机… adb wait-for-device @REM 循环安装本目录下的APK文件 FOR %%i IN (*.apk) DO ( ECHO 正在安装：%%i adb install &quot;%%i&quot; ) ECHO 安装完毕；请更换下一台手机！ PAUSE GOTO LOOP @ECHO on 9/21/2016 11:22:57 AM 问题 ：dialog dismiss 焦点跑到homeRecyclerView进行数据更新时焦点丢失的解决方案 : http://www.jianshu.com/p/749c0c91eb9c android:descendantFocusability=&quot;afterDescendants&quot; android:duplicateParentState=&quot;true&quot; 大数据优达学院 网址 :https://cn.udacity.com/ “我是一名码农,请尊重我的职业” 问题 ： notify后可以获取焦点，但不显示焦点框 9/22/2016 10:47:37 AM 问题 ：dilog 在卸软件卸载后弹出位置错位解决方法： 重新计算dilog 弹出的位置 x 轴计算问题 没有发现规律 可能是软件卸载后,布局跟新 微信公众平台 https://mp.weixin.qq.com/cgi-bin/home?token=511173594 问题 :app移动过程的bug解决方法: 调整移动的逻辑 9/23/2016 10:29:59 AM 问题 ：学籍注册移动的逻辑 ： 微信公众平台,小程序开发文档 :http://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432&amp;token=&amp;lang=zh_CN微信小程序： http://www.helloxcx.com/小程序api： http://wxopen.notedown.cn/ 9/24/2016 9:36:06 AM 显示网络错误的占位图片 Fresco 9/26/2016 9:47:03 AM 新建分类文件夹，显示预览效果 预览显示app icon从分类集合中获取显示，分类集合有多少显示多少 数据回显，存储info 到数据库中，并对每个分类添加分类的名字，根据类名查询该分类下的 所有信息 删除和替换，删除，从集合中删除，根据package name 从数据库删除 该app ； 替换：从集合中删除要替换的元素，并加入要替换的app ,从数据库中查找该分类删除该app，添加新的app info 9/27/2016 10:15:47 AM 分类页面展示app,数据的回显，删除和替换 回显数据的问题，初始化界面的是时候从sp 中获取集合mAddList，在adapter中显示，并添加一个空的待添加item,加到集合，每次点击添加，把添加的应用加到mAddList,把集合加到sp 中。 点击添加替换原来的坑位,增加一个坑位(在倒数第二个位置插入一个元素) 添加应用回显数据 添加到size-1 位置 ，notify 1. 替换回显会有问题2. 删除会回到主界面10/8/2016 9:55:34 AM 问题app 长按弹出 ,移动 ,卸载,替换,新建分类逻辑的实现解决卸载 替换 打开应用 数据回显 新建分类小程序教程网址http://www.helloxcx.com/article-20.php PAC 翻墙 https://www.seavia.com/share/iphone-ipad-mac-firefox-chrome-proxy.html 小米mini 路由翻墙https://seonoco.com/xiaomi-router-ss 问题app 移动和坑位焦点框出边界问题10/11/2016 9:14:51 AM android官网镜像网站 http://android.youdaxue.com/API 文档镜像 http://developer.android.youdaxue.com/guide/index.html优达Android基础视屏 https://classroom.udacity.com/courses/ud837/lessons/4027328704/concepts/43295507890923#Google 优达资源 https://discussions.youdaxue.com/t/android/84Google Play下载apk http://apps.evozi.com/apk-downloader 解决问题 App item 移动 理财平台 https://www.zhihu.com/question/24454597问题10/12/2016 10:34:49 AM app 移动dialog 没有一起移动 一个接口demo : http://www.jianshu.com/p/a28d4260a9d4View 的绘制流程 http://www.idtkm.com/customview/customview1/2016安卓开发资料大全 http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/1007/6660.html#10/13/2016 11:23:27 AM 两步搞定Fragment的返回键 http://blog.csdn.net/lx448593jp/article/details/51121581 Android 中文文档 http://hukai.me/android-training-course-in-chinese/basics/index.html10/14/2016 3:08:34 PM 数据10/17/2016 4:56:51 PM 首页问题 替换没有问题 新建 卸载 移动 item 错乱 使用imageloader 加载图片 一切都可以被改变11/1/2016 10:11:35 AM 长记性 获取view的位置 https://my.oschina.net/u/1376187/blog/172792获取view的坐标系：http://blog.csdn.net/jason0539/article/details/42743531问题 1: 切换后来RecylerView 没有焦点框 11/4/2016 9:37:00 AM RecyclerView 局部刷新闪烁 http://wetest.qq.com/lab/view/176.html?from=content_zhihuzhuanlanGoogle 镜像站 http://xiaoyu2er.github.io/2016/03/16/google-mirror/问题1 : 删除一个分类后焦点框不在正确的位置显示 (上面一行最后一个)问题2 : 点击卸载,在弹出对话框的时候点击取消,或者返回,item放大正常不能缩小 ( 在弹出菜单时候设置的放大造成的影响)问题3 : 在移动过程中操作item 位置不对应 （ 操纵的是前一个bean ）问题4 : 卸载应用后新的item不能缩小问题 ：11/8/2016 11:19:03 AM 软件安装和卸载后焦点丢失 移动过程中的放大效果 问题11/10/2016 9:18:41 AM 卸载后相同的应用没有卸载 卸载失败，取消有放大效果 移动过程中放大异常 11/11/2016 3:54:01 PM 问题 : 新建文件夹的逻辑问题 ,移动后新建退出 焦点异常 问题 ：11/14/2016 10:19:52 AM 判断记录head 的view 还是记录recyclerView 的view ，当Head 有焦点的时候将position置为-1 ，当RecyclerView 有焦点的时候将Head view 置为null 问题 :11/15/2016 9:45:02 AM 记录焦点的view 如果记录view 不为空让记录的view获取焦点，如果为menu 就让menu获取焦点 menu 有焦点就显示光圈 没有先不显示 （没有问题了 ） 如果menu hasfocus 按上下键 重现的position 设置为 -1 ； 快捷键: ctrl + p 参数提示 ctrl + j 自动代码 ctrl + n 查找类 自定义接口回掉 定义一个接口 OnxxListener 接口中的方法 onXxx() 在需要的回调事件的类中声明接口对象 ， OnxxListener xxlistener ;定义回掉的方法 setOnxxListener(OnxxListener listenr) 将接口对象赋值给listener this.listenr =xxListener 在事件发生的位置调用接口中的方法 xxlistener. onXxx(); 知乎日报Apihttps://github.com/izzyleung/ZhihuDailyPurify/wiki/%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5-API-%E5%88%86%E6%9E%90 gank io API http://gank.io/apimvp 模式获取天气实例 http://rocko.xyz/2015/02/06/Android%E4%B8%AD%E7%9A%84MVP/http://www.jianshu.com/p/9a6845b26856gank demo : http://blog.csdn.net/castledrv/article/details/51396637 model entity impl view ui fragment activity presenter impl listener 一个API http://v3.wufazhuce.com:8000/api/hp/bymonth/20161125###http://119.29.116.107:8088/fmms/ ### http://rest.wufazhuce.com/OneForWeb/one/getHpinfo?strDate=2016-07-25问答 http://v3.wufazhuce.com:8000/api/question/1282文章 http://v3.wufazhuce.com:8000/api/essay/1339首页 http://v3.wufazhuce.com:8000/api/hp/idlist/0首页详情 http://v3.wufazhuce.com:8000/api/hp/detail/1275其他 ：http://v3.wufazhuce.com:8000/api/music/idlist/0http://v3.wufazhuce.com:8000/api/movie/list/0http://v3.wufazhuce.com:8000/api/movie/detail/%1http://v3.wufazhuce.com:8000/api/reading/index/http://v3.wufazhuce.com:8000/api/music/detail/%1原网址https://gist.github.com/0312birdzhang/6d2ed45457c908a0d290bing 每日图片 api http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1混淆 ： 5分钟搞定android混淆 http://blog.csdn.net/jdsjlzx/article/details/51853423 11/29/2016 10:27:39 AM 问题 页面切换，如果有选中item恢复焦点，左边menu会抢焦点 解决办法 页面显示的时候，如果记录的有item 就让让所有button 不能获取焦点，焦点移动到左边，需要button 获取焦点的时候，监听按键，使button可以获取焦点 当button 获取焦点的时候判断是否有item记录，如果有就让不显示焦点图片，没有则显示 问题 新建文件夹添加应用后，将首页显示的item移除 从分类中删除，在首页恢复显示 解决办法 getDatas setDatas 11/30/2016 9:11:11 AM重新运行程序的时候，应用列表会显示文件夹 问题： 重新运行程序的时候，应用列表会显示文件夹 重新运行程序的时候，应用列表会显示文件夹 解决办法 判断类型再加入到集合中2. 12/1/2016 2:47:38 PM CSDN 投票 http://blog.csdn.net/vote/candidate.html?username=lmj623565791 问题 最近使用 应用收藏解决办法 使用数据库存储数据 ORMLite 12/2/2016 11:38:11 AM 框架应用https://bng86.gitbooks.io/android-third-party-/content/greendao.htmlORMlite 怎删改查 http://www.cnblogs.com/alexthecoder/p/4277758.html 12/3/2016 5:46:06 PM 问题 按下menu键 弹出管理应用的菜单 将移动变为收藏 按下ok键 显示移动菜单 如果是上面一行，不显示向上移动，显示其他操作 如果是下面一行，不显示向下移动，显示其他操作 问题 按ok键弹出菜单，item 上下左右移动 但 12/7/2016 9:18:41 AM 组装配置 cpu i5 6500 1200 显卡 gtx1050 1299 主板 华硕B150M-A M.2 500 电源 全汉蓝暴450w 269 机箱 金河田预见N6 169 散热 九州玄冰智能版 49 硬盘 内存 金士顿120G固态 2999. 明年双11 ================= 3486 网盘搜索工具 http://panc.cc/问题 焦点框的放大 按下返回键，焦点丢失 问题 上下移动没有view没有放大效果 删除文件夹焦点错乱 新建文件夹错乱 替换焦点框错乱 弹出菜单消失,页面 12/9/2016 1:58:46 PM 招商银行卡号 6214 8378 0241 2118 12/12/2016 10:43:30 AM Android 官方课程http://hukai.me/android-training-course-in-chinese/ 12/15/2016 2:36:08 PM 重新写数据库 12/16/2016 11:11:40 AM 12/19/2016 5:10:29 PM流程图工具 亿图图示 :http://www.edrawsoft.cn/ 12/21/2016 9:59:43 AM 先进行移动操作，然后点击新建文件夹，分类会执行移动操作 adb shell am start -n com.dy.dyth/.ui.activity.LaunchActivity 问题 选择移动,再选择分类,然后返回,弹出框没有影藏 保存移动和插入的数据(移动的数序,和插入的分类) 移动item 选择分类,遥控器按返回 焦点丢失 问题 新建分类或者删除焦点错位 移动到最后一个返回键，焦点框丢失3. 12/26/2016 5:16:48 PM 问题 移动到后面 页面切换的恢复错误 移动 和分类的混乱 加入分类的应用从首页删除 问题 选择新建分类,不输入名字,点击确定,焦点框错位 在分类中增加应用,返回首页 ,焦点框丢失 替换只显示首页的应用(就是不包括已经添加到分类) 应用分类，替换应用替换掉的重新显示在首页，新的应用从首页删除 adb截图命令adb shell /system/bin/screencap -p /sdcard/image.png adb pull /sdcard/image.png c:\\dir 问题 数据库内存泄露 Monkey 命令adb shell monkey -v -p com.dy.dyth --monitor-native-crashes --throttle 500 10000 &gt;D:/7.22-RK_1.LOG adb shell monkey -v -p com.dy.dyth --monitor-native-crashes --throttle 300 10000&gt;D:/5.7-RK1.LOG adb shell monkey -v -p com.dy.dyth --monitor-native-crashes --throttle 300 5000 &gt;D:/NL1.LOG //优客超级直播 1万次测试 adb shell monkey -v -p com.dy.dyth --monitor-native-crashes --throttle 300 1000 ps | grep monkey // 获取monkey 端口 adb shell monkey -p com.dy.dyth –-throttle 300 5000 &gt;D:/DYTH.LOG set rw.sw.defaultlauncherpackage com.dy.dyth set rw.sw.defaultlauncherclass com.dy.dyth.LaunchActivity set rw.sw.settofirstlauncher 0 1/3/2017 3:44:11 PM - 用户卸载软件 从收藏和最近使用中删除 tiem : 2.5火车 2.4 号高铁 2.4 初八 问题1.按下菜单键 选择替换 选择点击返回,在按下菜单键,按下返回,焦点丢失 抢票时间 12.30 武汉到深圳 z 13.30 武汉到深圳 高铁 16：00 襄阳到深圳 z232 16:00 襄阳东到广州 z124 z232 搭建个人博客教程地址https://xuanwo.org/2015/03/26/hexo-intor/ 教程http://blog.fens.me/hexo-blog-github/ 我的博客地址@gmailhttps://anran0919.github.io/ @163 mailhttps://ancorleone.github.io/ github ipping username.github.io 域名 https://dcc.godaddy.com/manage/http://jiji262.github.io/2016/04/15/2016-04-15-hexo-github-pages-blog/Hexo更新博客命令hexo clean // 清空 hexo g // 生成静态网页 hexo s // 预览 hexo d // 更新到github hexo 主题 github链接 给博客添加相册 github链接 GitHub上最火的Android开源项目持续更新中……github最大的痛点在于，拿到开源项目不会用，导入各种报错，readme看不懂，推荐给大家一个链接，所有的 项目都亲测没有问题并且全部配置了详细的步骤和配套视频进行解说，欢迎大家star。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://anranz.com/tags/笔记/"}]}]